// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 effective-5.10 (swiftlang-6.0.0.3.38 clang-1600.0.20.6)
// swift-module-flags: -disable-objc-attr-requires-foundation-module -target arm64-apple-ios18.0 -enable-objc-interop -enable-library-evolution -module-link-name swift_Concurrency -parse-stdlib -swift-version 5 -O -library-level api -enforce-exclusivity=unchecked -target-min-inlining-version min -enable-experimental-feature NoncopyableGenerics2 -enable-experimental-feature SuppressedAssociatedTypes -enable-experimental-feature ExtensionImportVisiblity -enable-experimental-feature IsolatedAny2 -user-module-version 6.0.0.3.38 -module-name _Concurrency
// swift-module-flags-ignorable: -enable-ossa-modules -enable-lexical-lifetimes=false
import Swift
import SwiftShims
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_marker public protocol AnyActor : AnyObject, Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol Actor : _Concurrency.AnyActor {
  nonisolated var unownedExecutor: _Concurrency.UnownedSerialExecutor { get }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_defaultActor_initialize")
public func _defaultActorInitialize(_ actor: Swift.AnyObject)
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@_silgen_name("swift_nonDefaultDistributedActor_initialize")
public func _nonDefaultDistributedActorInitialize(_ actor: Swift.AnyObject)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_defaultActor_destroy")
public func _defaultActorDestroy(_ actor: Swift.AnyObject)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueMainExecutor")
@usableFromInline
internal func _enqueueOnMain(_ job: _Concurrency.UnownedJob)
#if compiler(>=5.3) && $Macros && $FreestandingExpressionMacros
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@freestanding(expression) public macro isolation<T>() -> T = Builtin.IsolationMacro
#endif
#if compiler(>=5.3) && $ParameterPacks && $IsolatedAny
#if $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func extractIsolation<each Arg, Result>(_ fn: @escaping @isolated(any) @Sendable (repeat each Arg) async throws -> Result) -> (any _Concurrency.Actor)? {
  return Builtin.extractFunctionIsolation(fn)
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func extractIsolation<each Arg, Result>(_ fn: @escaping @isolated(any) @Sendable (repeat each Arg) async throws -> Result) -> (any _Concurrency.Actor)? {
  return Builtin.extractFunctionIsolation(fn)
}
#endif
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_start")
public func _asyncLetStart<T>(asyncLet: Builtin.RawPointer, options: Builtin.RawPointer?, operation: @Sendable () async throws -> T)
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_start")
public func _asyncLetStart<T>(asyncLet: Builtin.RawPointer, options: Builtin.RawPointer?, operation: @Sendable () async throws -> T)
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_wait")
public func _asyncLetGet<T>(asyncLet: Builtin.RawPointer) async -> T
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_wait_throwing")
public func _asyncLetGetThrowing<T>(asyncLet: Builtin.RawPointer) async throws -> T
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_end")
public func _asyncLetEnd(asyncLet: Builtin.RawPointer)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_get")
public func _asyncLet_get(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_get_throwing")
public func _asyncLet_get_throwing(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async throws
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_finish")
public func _asyncLet_finish(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct CheckedContinuation<T, E> : Swift.Sendable where E : Swift.Error {
  public init(continuation: _Concurrency.UnsafeContinuation<T, E>, function: Swift.String = #function)
  public func resume(returning value: __owned T)
  public func resume(throwing error: __owned E)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.CheckedContinuation {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func resume<Er>(with result: Swift.Result<T, Er>) where E == any Swift.Error, Er : Swift.Error {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  #else
  @_alwaysEmitIntoClient public func resume<Er>(with result: Swift.Result<T, Er>) where E == any Swift.Error, Er : Swift.Error {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func resume(with result: Swift.Result<T, E>) {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  #else
  @_alwaysEmitIntoClient public func resume(with result: Swift.Result<T, E>) {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  #endif
  @_alwaysEmitIntoClient public func resume() where T == () {
    self.resume(returning: ())
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @inlinable public func withCheckedContinuation<T>(function: Swift.String = #function, _ body: (_Concurrency.CheckedContinuation<T, Swift.Never>) -> Swift.Void) async -> T {
  return await withUnsafeContinuation {
    body(CheckedContinuation(continuation: $0, function: function))
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @inlinable public func withCheckedThrowingContinuation<T>(function: Swift.String = #function, _ body: (_Concurrency.CheckedContinuation<T, any Swift.Error>) -> Swift.Void) async throws -> T {
  return try await withUnsafeThrowingContinuation {
    body(CheckedContinuation(continuation: $0, function: function))
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _createCheckedContinuation<T>(_ continuation: __owned _Concurrency.UnsafeContinuation<T, Swift.Never>) -> _Concurrency.CheckedContinuation<T, Swift.Never> {
  return CheckedContinuation(continuation: continuation)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _createCheckedThrowingContinuation<T>(_ continuation: __owned _Concurrency.UnsafeContinuation<T, any Swift.Error>) -> _Concurrency.CheckedContinuation<T, any Swift.Error> {
  return CheckedContinuation(continuation: continuation)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeCheckedContinuation<T>(_ continuation: _Concurrency.CheckedContinuation<T, Swift.Never>, _ value: __owned T) {
  continuation.resume(returning: value)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeCheckedThrowingContinuation<T>(_ continuation: _Concurrency.CheckedContinuation<T, any Swift.Error>, _ value: __owned T) {
  continuation.resume(returning: value)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeCheckedThrowingContinuationWithError<T>(_ continuation: _Concurrency.CheckedContinuation<T, any Swift.Error>, _ error: __owned any Swift.Error) {
  continuation.resume(throwing: error)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_deletedAsyncMethodError")
public func swift_deletedAsyncMethodError() async
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol Executor : AnyObject, Swift.Sendable {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  func enqueue(_ job: _Concurrency.UnownedJob)
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @available(*, deprecated, message: "Implement 'enqueue(_: consuming ExecutorJob)' instead")
  func enqueue(_ job: consuming _Concurrency.Job)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol SerialExecutor : _Concurrency.Executor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @available(*, deprecated, message: "Implement 'enqueue(_: consuming ExecutorJob)' instead")
  @_nonoverride func enqueue(_ job: _Concurrency.UnownedJob)
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @available(*, deprecated, message: "Implement 'enqueue(_: consuming ExecutorJob)' instead")
  @_nonoverride func enqueue(_ job: consuming _Concurrency.Job)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @_nonoverride func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  #endif
  func asUnownedSerialExecutor() -> _Concurrency.UnownedSerialExecutor
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  func isSameExclusiveExecutionContext(other: Self) -> Swift.Bool
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  func checkIsolated()
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func checkIsolated()
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol TaskExecutor : _Concurrency.Executor {
  @_nonoverride func enqueue(_ job: _Concurrency.UnownedJob)
  #if compiler(>=5.3) && $MoveOnly
  @available(*, deprecated, message: "Implement 'enqueue(_: consuming ExecutorJob)' instead")
  @_nonoverride func enqueue(_ job: consuming _Concurrency.Job)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  @_nonoverride func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  #endif
  func asUnownedTaskExecutor() -> _Concurrency.UnownedTaskExecutor
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.TaskExecutor {
  public func asUnownedTaskExecutor() -> _Concurrency.UnownedTaskExecutor
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.Executor {
  public func enqueue(_ job: _Concurrency.UnownedJob)
  #if compiler(>=5.3) && $MoveOnly
  public func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  public func enqueue(_ job: consuming _Concurrency.Job)
  #endif
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func asUnownedSerialExecutor() -> _Concurrency.UnownedSerialExecutor
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func isSameExclusiveExecutionContext(other: Self) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnownedSerialExecutor : Swift.Sendable {
  @usableFromInline
  internal var executor: Builtin.Executor
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var _executor: Builtin.Executor {
    get
  }
  @inlinable public init(_ executor: Builtin.Executor) {
    #if compiler(>=5.5) && $BuiltinExecutor
    self.executor = executor
    #endif
  }
  @inlinable public init<E>(ordinary executor: __shared E) where E : _Concurrency.SerialExecutor {
    #if compiler(>=5.5) && $BuiltinBuildExecutor
    self.executor = Builtin.buildOrdinarySerialExecutorRef(executor)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @inlinable public init<E>(complexEquality executor: __shared E) where E : _Concurrency.SerialExecutor {
    #if compiler(>=5.9) && $BuiltinBuildComplexEqualityExecutor
    self.executor = Builtin.buildComplexEqualitySerialExecutorRef(executor)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen public struct UnownedTaskExecutor : Swift.Sendable {
  @usableFromInline
  internal var executor: Builtin.Executor
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var _executor: Builtin.Executor {
    get
  }
  @inlinable public init(_ executor: Builtin.Executor) {
    #if $BuiltinExecutor
    self.executor = executor
    #endif
  }
  @inlinable public init<E>(ordinary executor: __shared E) where E : _Concurrency.TaskExecutor {
    #if $BuiltinBuildTaskExecutorRef
    self.executor = Builtin.buildOrdinaryTaskExecutorRef(executor)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.UnownedTaskExecutor : Swift.Equatable {
  @inlinable public static func == (lhs: _Concurrency.UnownedTaskExecutor, rhs: _Concurrency.UnownedTaskExecutor) -> Swift.Bool {
    unsafeBitCast(lhs.executor, to: (Int, Int).self) == unsafeBitCast(rhs.executor, to: (Int, Int).self)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_transparent public func _checkExpectedExecutor(_filenameStart: Builtin.RawPointer, _filenameLength: Builtin.Word, _filenameIsASCII: Builtin.Int1, _line: Builtin.Word, _executor: Builtin.Executor) {
  if _taskIsCurrentExecutor(_executor) {
    return
  }

  _reportUnexpectedExecutor(
      _filenameStart, _filenameLength, _filenameIsASCII, _line, _executor)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  public func preconditionIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line) {
    guard _isDebugAssertConfiguration() || _isReleaseAssertConfiguration() else {
      return
    }

    let expectationCheck = _taskIsCurrentExecutor(self.asUnownedSerialExecutor().executor)

     
    precondition(expectationCheck,
         
        "Incorrect actor executor assumption; Expected '\(self)' executor. \(message())",
        file: file, line: line)  
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Actor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  nonisolated public func preconditionIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line) {
    guard _isDebugAssertConfiguration() || _isReleaseAssertConfiguration() else {
      return
    }

     
     
     
    let expectationCheck = _taskIsCurrentExecutor(self.unownedExecutor.executor)

    precondition(expectationCheck,
        "Incorrect actor executor assumption; Expected '\(self.unownedExecutor)' executor. \(message())",
        file: file, line: line)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.GlobalActor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  public static func preconditionIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line) {
    Self.shared.preconditionIsolated(message(), file: file, line: line)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.SerialExecutor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  public func assertIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line) {
    guard _isDebugAssertConfiguration() else {
      return
    }

    guard _taskIsCurrentExecutor(self.asUnownedSerialExecutor().executor) else {
       
      let msg = "Incorrect actor executor assumption; Expected '\(self)' executor. \(message())"
       
      assertionFailure(msg, file: file, line: line)
      return
    }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Actor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  nonisolated public func assertIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line) {
    guard _isDebugAssertConfiguration() else {
      return
    }

    guard _taskIsCurrentExecutor(self.unownedExecutor.executor) else {
      let msg = "Incorrect actor executor assumption; Expected '\(self.unownedExecutor)' executor. \(message())"
       
      assertionFailure(msg, file: file, line: line)  
      return
    }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.GlobalActor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  public static func assertIsolated(_ message: @autoclosure () -> Swift.String = String(), file: Swift.StaticString = #fileID, line: Swift.UInt = #line) {
    Self.shared.assertIsolated(message(), file: file, line: line)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Actor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_alwaysEmitIntoClient @_unavailableFromAsync(message: "express the closure as an explicit function declared on the specified 'actor' instead") nonisolated public func assumeIsolated<T>(_ operation: (isolated Self) throws -> T, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) rethrows -> T where T : Swift.Sendable {
    typealias YesActor = (isolated Self) throws -> T
    typealias NoActor = (Self) throws -> T

     
     
    let executor: Builtin.Executor = self.unownedExecutor.executor
    guard _taskIsCurrentExecutor(executor) else {
       
      fatalError("Incorrect actor executor assumption; Expected same executor as \(self).", file: file, line: line)
    }

    #if $TypedThrows
     
    return try withoutActuallyEscaping(operation) {
      (_ fn: @escaping YesActor) throws -> T in
      let rawFn = unsafeBitCast(fn, to: NoActor.self)
      return try rawFn(self)
    }
    #else
    fatalError("unsupported compiler")
    #endif
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  @_silgen_name("$sScAsE14assumeIsolated_4file4lineqd__qd__xYiKXE_s12StaticStringVSutKlF")
  nonisolated internal func __abi__assumeIsolated<T>(_ operation: (isolated Self) throws -> T, _ file: Swift.StaticString, _ line: Swift.UInt) rethrows -> T where T : Swift.Sendable
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @preconcurrency @inlinable public __consuming func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> ElementOfResult?) -> _Concurrency.AsyncCompactMapSequence<Self, ElementOfResult> {
    return AsyncCompactMapSequence(self, transform: transform)
  }
  #else
  @preconcurrency @inlinable public __consuming func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> ElementOfResult?) -> _Concurrency.AsyncCompactMapSequence<Self, ElementOfResult> {
    return AsyncCompactMapSequence(self, transform: transform)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncCompactMapSequence<Base, ElementOfResult> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> ElementOfResult?
  #if compiler(>=5.3) && $NoncopyableGenerics
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> ElementOfResult?)
  #else
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> ElementOfResult?)
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncCompactMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = ElementOfResult
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Failure = Base.Failure
  public typealias AsyncIterator = _Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ElementOfResult
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Failure = Base.Failure
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> ElementOfResult?
    #if compiler(>=5.3) && $NoncopyableGenerics
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> ElementOfResult?)
    #else
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> ElementOfResult?)
    #endif
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async rethrows -> ElementOfResult? {
      while true {
        guard let element = try await baseIterator.next() else {
          return nil
        }

        if let transformed = await transform(element) {
          return transformed
        }
      }
    }
    #else
    @inlinable public mutating func next() async rethrows -> ElementOfResult? {
      while true {
        guard let element = try await baseIterator.next() else {
          return nil
        }

        if let transformed = await transform(element) {
          return transformed
        }
      }
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator.Failure) -> ElementOfResult? {
      while true {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }

        if let transformed = await transform(element) {
          return transformed
        }
      }
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator.Failure) -> ElementOfResult? {
      while true {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }

        if let transformed = await transform(element) {
          return transformed
        }
      }
    }
    #endif
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncCompactMapSequence<Base, ElementOfResult>.Iterator.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncCompactMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, ElementOfResult : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncCompactMapSequence.Iterator : @unchecked Swift.Sendable where ElementOfResult : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @inlinable public __consuming func dropFirst(_ count: Swift.Int = 1) -> _Concurrency.AsyncDropFirstSequence<Self> {
    precondition(count >= 0, 
      "Can't drop a negative number of elements from an async sequence")
    return AsyncDropFirstSequence(self, dropping: count)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncDropFirstSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let count: Swift.Int
  @usableFromInline
  internal init(_ base: Base, dropping count: Swift.Int)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Failure = Base.Failure
  public typealias AsyncIterator = _Concurrency.AsyncDropFirstSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Failure = Base.Failure
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var count: Swift.Int
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, count: Swift.Int)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      var remainingToDrop = count
      while remainingToDrop > 0 {
        guard try await baseIterator.next() != nil else {
          count = 0
          return nil
        }
        remainingToDrop -= 1
      }
      count = 0
      return try await baseIterator.next()
    }
    #else
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      var remainingToDrop = count
      while remainingToDrop > 0 {
        guard try await baseIterator.next() != nil else {
          count = 0
          return nil
        }
        remainingToDrop -= 1
      }
      count = 0
      return try await baseIterator.next()
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncDropFirstSequence<Base>.Iterator.Failure) -> Base.Element? {
      var remainingToDrop = count
      while remainingToDrop > 0 {
        guard try await baseIterator.next(isolation: actor) != nil else {
          count = 0
          return nil
        }
        remainingToDrop -= 1
      }
      count = 0
      return try await baseIterator.next(isolation: actor)
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncDropFirstSequence<Base>.Iterator.Failure) -> Base.Element? {
      var remainingToDrop = count
      while remainingToDrop > 0 {
        guard try await baseIterator.next(isolation: actor) != nil else {
          count = 0
          return nil
        }
        remainingToDrop -= 1
      }
      count = 0
      return try await baseIterator.next(isolation: actor)
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncDropFirstSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), count: count)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncDropFirstSequence<Base>.Iterator.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncDropFirstSequence<Base>.Iterator.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence {
  @inlinable public __consuming func dropFirst(_ count: Swift.Int = 1) -> _Concurrency.AsyncDropFirstSequence<Base> {
      
     
    precondition(count >= 0, 
      "Can't drop a negative number of elements from an async sequence")
    return AsyncDropFirstSequence(base, dropping: self.count + count)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence : Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropFirstSequence.Iterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func drop(while predicate: @escaping @Sendable (Self.Element) async -> Swift.Bool) -> _Concurrency.AsyncDropWhileSequence<Self> {
    AsyncDropWhileSequence(self, predicate: predicate)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncDropWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async -> Swift.Bool
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async -> Swift.Bool)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Failure = Base.Failure
  public typealias AsyncIterator = _Concurrency.AsyncDropWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Failure = Base.Failure
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var predicate: ((Base.Element) async -> Swift.Bool)?
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async -> Swift.Bool)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      while let predicate = self.predicate {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        if await predicate(element) == false {
          self.predicate = nil
          return element
        }
      }
      return try await baseIterator.next()
    }
    #else
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      while let predicate = self.predicate {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        if await predicate(element) == false {
          self.predicate = nil
          return element
        }
      }
      return try await baseIterator.next()
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncDropWhileSequence<Base>.Iterator.Failure) -> Base.Element? {
      while let predicate = self.predicate {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }
        if await predicate(element) == false {
          self.predicate = nil
          return element
        }
      }
      return try await baseIterator.next(isolation: actor)
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncDropWhileSequence<Base>.Iterator.Failure) -> Base.Element? {
      while let predicate = self.predicate {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }
        if await predicate(element) == false {
          self.predicate = nil
          return element
        }
      }
      return try await baseIterator.next(isolation: actor)
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncDropWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncDropWhileSequence<Base>.Iterator.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncDropWhileSequence<Base>.Iterator.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropWhileSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncDropWhileSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func filter(_ isIncluded: @escaping @Sendable (Self.Element) async -> Swift.Bool) -> _Concurrency.AsyncFilterSequence<Self> {
    return AsyncFilterSequence(self, isIncluded: isIncluded)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncFilterSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let isIncluded: (_Concurrency.AsyncFilterSequence<Base>.Element) async -> Swift.Bool
  @usableFromInline
  internal init(_ base: Base, isIncluded: @escaping (Base.Element) async -> Swift.Bool)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFilterSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Failure = Base.Failure
  public typealias AsyncIterator = _Concurrency.AsyncFilterSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Failure = Base.Failure
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let isIncluded: (Base.Element) async -> Swift.Bool
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, isIncluded: @escaping (Base.Element) async -> Swift.Bool)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      while true {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        if await isIncluded(element) {
          return element
        }
      }
    }
    #else
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      while true {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        if await isIncluded(element) {
          return element
        }
      }
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncFilterSequence<Base>.Iterator.Failure) -> Base.Element? {
      while true {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }
        if await isIncluded(element) {
          return element
        }
      }
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncFilterSequence<Base>.Iterator.Failure) -> Base.Element? {
      while true {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }
        if await isIncluded(element) {
          return element
        }
      }
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncFilterSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), isIncluded: isIncluded)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncFilterSequence<Base>.Iterator.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncFilterSequence<Base>.Iterator.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFilterSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFilterSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @usableFromInline
  @preconcurrency internal __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> SegmentOfResult) -> _Concurrency.AsyncFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence
  @preconcurrency @_alwaysEmitIntoClient @inlinable public __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> SegmentOfResult) -> _Concurrency.AsyncFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence, Self.Failure == SegmentOfResult.Failure {
    return AsyncFlatMapSequence(self, transform: transform)
  }
  @preconcurrency @_alwaysEmitIntoClient @inlinable public __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> SegmentOfResult) -> _Concurrency.AsyncFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence, SegmentOfResult.Failure == Swift.Never {
    return AsyncFlatMapSequence(self, transform: transform)
  }
  @preconcurrency @_alwaysEmitIntoClient @inlinable public __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> SegmentOfResult) -> _Concurrency.AsyncFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence, Self.Failure == Swift.Never, SegmentOfResult.Failure == Swift.Never {
    return AsyncFlatMapSequence(self, transform: transform)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncFlatMapSequence<Base, SegmentOfResult> where Base : _Concurrency.AsyncSequence, SegmentOfResult : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> SegmentOfResult
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> SegmentOfResult)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFlatMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = SegmentOfResult.Element
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Failure = Base.Failure
  public typealias AsyncIterator = _Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Failure = Base.Failure
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> SegmentOfResult
    @usableFromInline
    internal var currentIterator: SegmentOfResult.AsyncIterator?
    @usableFromInline
    internal var finished: Swift.Bool
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> SegmentOfResult)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async rethrows -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
             
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next() else {
            finished = true
            return nil
          }
          do { 
            let segment = await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        }
      }
      return nil
    }
    #else
    @inlinable public mutating func next() async rethrows -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
             
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next() else {
            finished = true
            return nil
          }
          do { 
            let segment = await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        }
      }
      return nil
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator.Failure) -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            let optElement = try await iterator.next(isolation: actor)
            guard let element = optElement else {
              currentIterator = nil
              continue
            }
             
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error as! Failure
          }
        } else {
          let optItem = try await baseIterator.next(isolation: actor)
          guard let item = optItem else {
            finished = true
            return nil
          }
          do {
            let segment = await transform(item)
            var iterator = segment.makeAsyncIterator()
            let optElement = try await iterator.next(isolation: actor)  
            guard let element = optElement else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error as! Failure
          }
        }
      }
      return nil
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator.Failure) -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            let optElement = try await iterator.next(isolation: actor)
            guard let element = optElement else {
              currentIterator = nil
              continue
            }
             
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error as! Failure
          }
        } else {
          let optItem = try await baseIterator.next(isolation: actor)
          guard let item = optItem else {
            finished = true
            return nil
          }
          do {
            let segment = await transform(item)
            var iterator = segment.makeAsyncIterator()
            let optElement = try await iterator.next(isolation: actor)  
            guard let element = optElement else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error as! Failure
          }
        }
      }
      return nil
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = SegmentOfResult.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFlatMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, SegmentOfResult : Swift.Sendable, Base.Element : Swift.Sendable, SegmentOfResult.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncFlatMapSequence.Iterator : @unchecked Swift.Sendable where SegmentOfResult : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable, SegmentOfResult.AsyncIterator : Swift.Sendable, SegmentOfResult.Element : Swift.Sendable {
}
#if compiler(>=5.3) && $AsyncSequenceFailure
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol AsyncIteratorProtocol<Element, Failure> {
  associatedtype Element
  #if compiler(>=5.3) && $AssociatedTypeAvailability
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  associatedtype Failure : Swift.Error = any Swift.Error
  #else
  associatedtype Failure : Swift.Error = any Swift.Error
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  mutating func next() async throws -> Self.Element?
  #else
  mutating func next() async throws -> Self.Element?
  #endif
  #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
  #if $NoncopyableGenerics
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Self.Failure) -> Self.Element?
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Self.Failure) -> Self.Element?
  #endif
  #endif
}
#elseif compiler(>=5.3) && $PrimaryAssociatedTypes2
@rethrows
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol AsyncIteratorProtocol<Element, Failure> {
  associatedtype Element
  #if compiler(>=5.3) && $AssociatedTypeAvailability
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  associatedtype Failure : Swift.Error = any Swift.Error
  #else
  associatedtype Failure : Swift.Error = any Swift.Error
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  mutating func next() async throws -> Self.Element?
  #else
  mutating func next() async throws -> Self.Element?
  #endif
  #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
  #if $NoncopyableGenerics
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Self.Failure) -> Self.Element?
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Self.Failure) -> Self.Element?
  #endif
  #endif
}
#else
@rethrows
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol AsyncIteratorProtocol {
  associatedtype Element
  #if compiler(>=5.3) && $AssociatedTypeAvailability
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  associatedtype Failure : Swift.Error = any Swift.Error
  #else
  associatedtype Failure : Swift.Error = any Swift.Error
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  mutating func next() async throws -> Self.Element?
  #else
  mutating func next() async throws -> Self.Element?
  #endif
  #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
  #if $NoncopyableGenerics
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Self.Failure) -> Self.Element?
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Self.Failure) -> Self.Element?
  #endif
  #endif
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncIteratorProtocol {
  #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
  #if $NoncopyableGenerics
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Self.Failure) -> Self.Element? {
    do {
      return try await next()
    } catch {
      throw error as! Failure
    }
  }
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Self.Failure) -> Self.Element? {
    do {
      return try await next()
    } catch {
      throw error as! Failure
    }
  }
  #endif
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func map<Transformed>(_ transform: @escaping @Sendable (Self.Element) async -> Transformed) -> _Concurrency.AsyncMapSequence<Self, Transformed> {
    return AsyncMapSequence(self, transform: transform)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncMapSequence<Base, Transformed> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async -> Transformed
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async -> Transformed)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = Transformed
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Failure = Base.Failure
  public typealias AsyncIterator = _Concurrency.AsyncMapSequence<Base, Transformed>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Failure = Base.Failure
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async -> Transformed
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> Transformed)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async rethrows -> Transformed? {
      guard let element = try await baseIterator.next() else {
        return nil
      }
      return await transform(element)
    }
    #else
    @inlinable public mutating func next() async rethrows -> Transformed? {
      guard let element = try await baseIterator.next() else {
        return nil
      }
      return await transform(element)
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncMapSequence<Base, Transformed>.Iterator.Failure) -> Transformed? {
      guard let element = try await baseIterator.next(isolation: actor) else {
        return nil
      }
      return await transform(element)
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncMapSequence<Base, Transformed>.Iterator.Failure) -> Transformed? {
      guard let element = try await baseIterator.next(isolation: actor) else {
        return nil
      }
      return await transform(element)
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Transformed
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncMapSequence<Base, Transformed>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncMapSequence<Base, Transformed>.Iterator.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncMapSequence<Base, Transformed>.Iterator.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Transformed : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncMapSequence.Iterator : @unchecked Swift.Sendable where Transformed : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @inlinable public __consuming func prefix(_ count: Swift.Int) -> _Concurrency.AsyncPrefixSequence<Self> {
    precondition(count >= 0,
      "Can't prefix a negative number of elements from an async sequence")
    return AsyncPrefixSequence(self, count: count)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncPrefixSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let count: Swift.Int
  @usableFromInline
  internal init(_ base: Base, count: Swift.Int)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Failure = Base.Failure
  public typealias AsyncIterator = _Concurrency.AsyncPrefixSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Failure = Base.Failure
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal var remaining: Swift.Int
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, count: Swift.Int)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      if remaining != 0 {
        remaining &-= 1
        return try await baseIterator.next()
      } else {
        return nil
      }
    }
    #else
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      if remaining != 0 {
        remaining &-= 1
        return try await baseIterator.next()
      } else {
        return nil
      }
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncPrefixSequence<Base>.Iterator.Failure) -> Base.Element? {
      if remaining != 0 {
        remaining &-= 1
        return try await baseIterator.next(isolation: actor)
      } else {
        return nil
      }
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncPrefixSequence<Base>.Iterator.Failure) -> Base.Element? {
      if remaining != 0 {
        remaining &-= 1
        return try await baseIterator.next(isolation: actor)
      } else {
        return nil
      }
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncPrefixSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), count: count)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncPrefixSequence<Base>.Iterator.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncPrefixSequence<Base>.Iterator.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixSequence : Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixSequence.Iterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func prefix(while predicate: @escaping @Sendable (Self.Element) async -> Swift.Bool) rethrows -> _Concurrency.AsyncPrefixWhileSequence<Self> {
    return AsyncPrefixWhileSequence(self, predicate: predicate)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncPrefixWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async -> Swift.Bool
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async -> Swift.Bool)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias Failure = Base.Failure
  public typealias AsyncIterator = _Concurrency.AsyncPrefixWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Failure = Base.Failure
    @usableFromInline
    internal var predicateHasFailed: Swift.Bool
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async -> Swift.Bool
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async -> Swift.Bool)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next() {
        if await predicate(nextElement) {
          return nextElement
        } else {
          predicateHasFailed = true
        }
      }
      return nil
    }
    #else
    @inlinable public mutating func next() async rethrows -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next() {
        if await predicate(nextElement) {
          return nextElement
        } else {
          predicateHasFailed = true
        }
      }
      return nil
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncPrefixWhileSequence<Base>.Iterator.Failure) -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next(isolation: actor) {
        if await predicate(nextElement) {
          return nextElement
        } else {
          predicateHasFailed = true
        }
      }
      return nil
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(_Concurrency.AsyncPrefixWhileSequence<Base>.Iterator.Failure) -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next(isolation: actor) {
        if await predicate(nextElement) {
          return nextElement
        } else {
          predicateHasFailed = true
        }
      }
      return nil
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Base.Element
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncPrefixWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncPrefixWhileSequence<Base>.Iterator.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncPrefixWhileSequence<Base>.Iterator.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixWhileSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncPrefixWhileSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
#if compiler(>=5.3) && $AsyncSequenceFailure
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol AsyncSequence<Element, Failure> {
  associatedtype AsyncIterator : _Concurrency.AsyncIteratorProtocol
  associatedtype Element where Self.Element == Self.AsyncIterator.Element
  #if compiler(>=5.3) && $AssociatedTypeAvailability
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  associatedtype Failure = Self.AsyncIterator.Failure where Self.Failure == Self.AsyncIterator.Failure
  #else
  associatedtype Failure = Self.AsyncIterator.Failure where Self.Failure == Self.AsyncIterator.Failure
  #endif
  __consuming func makeAsyncIterator() -> Self.AsyncIterator
}
#elseif compiler(>=5.3) && $PrimaryAssociatedTypes2
@rethrows
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol AsyncSequence<Element, Failure> {
  associatedtype AsyncIterator : _Concurrency.AsyncIteratorProtocol
  associatedtype Element where Self.Element == Self.AsyncIterator.Element
  #if compiler(>=5.3) && $AssociatedTypeAvailability
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  associatedtype Failure = Self.AsyncIterator.Failure where Self.Failure == Self.AsyncIterator.Failure
  #else
  associatedtype Failure = Self.AsyncIterator.Failure where Self.Failure == Self.AsyncIterator.Failure
  #endif
  __consuming func makeAsyncIterator() -> Self.AsyncIterator
}
#else
@rethrows
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol AsyncSequence {
  associatedtype AsyncIterator : _Concurrency.AsyncIteratorProtocol
  associatedtype Element where Self.Element == Self.AsyncIterator.Element
  #if compiler(>=5.3) && $AssociatedTypeAvailability
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  associatedtype Failure = Self.AsyncIterator.Failure where Self.Failure == Self.AsyncIterator.Failure
  #else
  associatedtype Failure = Self.AsyncIterator.Failure where Self.Failure == Self.AsyncIterator.Failure
  #endif
  __consuming func makeAsyncIterator() -> Self.AsyncIterator
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) async throws -> Result) async rethrows -> Result {
    var accumulator = initialResult
    var iterator = makeAsyncIterator()
    while let element = try await iterator.next() {
      accumulator = try await nextPartialResult(accumulator, element)
    }
    return accumulator
  }
  @inlinable public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Self.Element) async throws -> Swift.Void) async rethrows -> Result {
    var accumulator = initialResult
    var iterator = makeAsyncIterator()
    while let element = try await iterator.next() {
      try await updateAccumulatingResult(&accumulator, element)
    }
    return accumulator
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) internal func _contains<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool where Source : _Concurrency.AsyncSequence {
  for try await element in self {
    if try await predicate(element) {
      return true
    }
  }
  return false
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @inlinable public func contains(where predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool {
    return try await _contains(self, where: predicate)
  }
  @inlinable public func allSatisfy(_ predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Swift.Bool {
    return try await !contains { try await !predicate($0) }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence where Self.Element : Swift.Equatable {
  @inlinable public func contains(_ search: Self.Element) async rethrows -> Swift.Bool {
    for try await element in self {
      if element == search {
        return true
      }
    }
    return false
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) internal func _first<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Swift.Bool) async rethrows -> Source.Element? where Source : _Concurrency.AsyncSequence {
  for try await element in self {
    if try await predicate(element) {
      return element
    }
  }
  return nil
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) internal func _first<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Swift.Bool) async rethrows -> Source.Element? where Source : _Concurrency.AsyncSequence {
  for try await element in self {
    if try await predicate(element) {
      return element
    }
  }
  return nil
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @inlinable public func first(where predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    return try await _first(self, where: predicate)
  }
  #else
  @inlinable public func first(where predicate: (Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    return try await _first(self, where: predicate)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @warn_unqualified_access
  @inlinable public func min(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    var it = makeAsyncIterator()
    guard var result = try await it.next() else { 
      return nil 
    }
    while let e = try await it.next() {
      if try await areInIncreasingOrder(e, result) { 
        result = e 
      }
    }
    return result
  }
  #else
  @warn_unqualified_access
  @inlinable public func min(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    var it = makeAsyncIterator()
    guard var result = try await it.next() else { 
      return nil 
    }
    while let e = try await it.next() {
      if try await areInIncreasingOrder(e, result) { 
        result = e 
      }
    }
    return result
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @warn_unqualified_access
  @inlinable public func max(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    var it = makeAsyncIterator()
    guard var result = try await it.next() else { 
      return nil 
    }
    while let e = try await it.next() {
      if try await areInIncreasingOrder(result, e) { 
        result = e 
      }
    }
    return result
  }
  #else
  @warn_unqualified_access
  @inlinable public func max(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Swift.Bool) async rethrows -> Self.Element? {
    var it = makeAsyncIterator()
    guard var result = try await it.next() else { 
      return nil 
    }
    while let e = try await it.next() {
      if try await areInIncreasingOrder(result, e) { 
        result = e 
      }
    }
    return result
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence where Self.Element : Swift.Comparable {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @warn_unqualified_access
  @inlinable public func min() async rethrows -> Self.Element? {
    return try await self.min(by: <)
  }
  #else
  @warn_unqualified_access
  @inlinable public func min() async rethrows -> Self.Element? {
    return try await self.min(by: <)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @warn_unqualified_access
  @inlinable public func max() async rethrows -> Self.Element? {
    return try await self.max(by: <)
  }
  #else
  @warn_unqualified_access
  @inlinable public func max() async rethrows -> Self.Element? {
    return try await self.max(by: <)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @preconcurrency @inlinable public __consuming func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Self.Element) async throws -> ElementOfResult?) -> _Concurrency.AsyncThrowingCompactMapSequence<Self, ElementOfResult> {
    return AsyncThrowingCompactMapSequence(self, transform: transform)
  }
  #else
  @preconcurrency @inlinable public __consuming func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Self.Element) async throws -> ElementOfResult?) -> _Concurrency.AsyncThrowingCompactMapSequence<Self, ElementOfResult> {
    return AsyncThrowingCompactMapSequence(self, transform: transform)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingCompactMapSequence<Base, ElementOfResult> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> ElementOfResult?
  #if compiler(>=5.3) && $NoncopyableGenerics
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
  #else
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingCompactMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = ElementOfResult
  public typealias Failure = any Swift.Error
  public typealias AsyncIterator = _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ElementOfResult
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> ElementOfResult?
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $NoncopyableGenerics
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
    #else
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
    #endif
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async throws -> ElementOfResult? {
      while !finished {
        guard let element = try await baseIterator.next() else {
          finished = true
          return nil
        }
        do {
          if let transformed = try await transform(element) {
            return transformed
          }
        } catch {
          finished = true
          throw error
        }
      }
      return nil
    }
    #else
    @inlinable public mutating func next() async throws -> ElementOfResult? {
      while !finished {
        guard let element = try await baseIterator.next() else {
          finished = true
          return nil
        }
        do {
          if let transformed = try await transform(element) {
            return transformed
          }
        } catch {
          finished = true
          throw error
        }
      }
      return nil
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> ElementOfResult? {
      while !finished {
        guard let element = try await baseIterator.next(isolation: actor) else {
          finished = true
          return nil
        }
        do {
          if let transformed = try await transform(element) {
            return transformed
          }
        } catch {
          finished = true
          throw error
        }
      }
      return nil
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> ElementOfResult? {
      while !finished {
        guard let element = try await baseIterator.next(isolation: actor) else {
          finished = true
          return nil
        }
        do {
          if let transformed = try await transform(element) {
            return transformed
          }
        } catch {
          finished = true
          throw error
        }
      }
      return nil
    }
    #endif
    #endif
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Failure
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Failure
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingCompactMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingCompactMapSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func drop(while predicate: @escaping @Sendable (Self.Element) async throws -> Swift.Bool) -> _Concurrency.AsyncThrowingDropWhileSequence<Self> {
    AsyncThrowingDropWhileSequence(self, predicate: predicate)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingDropWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async throws -> Swift.Bool
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingDropWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias Failure = any Swift.Error
  public typealias AsyncIterator = _Concurrency.AsyncThrowingDropWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async throws -> Swift.Bool
    @usableFromInline
    internal var finished: Swift.Bool
    @usableFromInline
    internal var doneDropping: Swift.Bool
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async throws -> Base.Element? {
      while !finished && !doneDropping {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        do {
          if try await predicate(element) == false {
            doneDropping = true
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }
      guard !finished else { 
        return nil
      }
      return try await baseIterator.next()
    }
    #else
    @inlinable public mutating func next() async throws -> Base.Element? {
      while !finished && !doneDropping {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        do {
          if try await predicate(element) == false {
            doneDropping = true
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }
      guard !finished else { 
        return nil
      }
      return try await baseIterator.next()
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> Base.Element? {
      while !finished && !doneDropping {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }
        do {
          if try await predicate(element) == false {
            doneDropping = true
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }
      guard !finished else { 
        return nil
      }
      return try await baseIterator.next(isolation: actor)
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> Base.Element? {
      while !finished && !doneDropping {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }
        do {
          if try await predicate(element) == false {
            doneDropping = true
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }
      guard !finished else { 
        return nil
      }
      return try await baseIterator.next(isolation: actor)
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Base.Element
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingDropWhileSequence<Base>.Failure
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingDropWhileSequence<Base>.Failure
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingDropWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingDropWhileSequence<Base>.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingDropWhileSequence<Base>.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingDropWhileSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingDropWhileSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func filter(_ isIncluded: @escaping @Sendable (Self.Element) async throws -> Swift.Bool) -> _Concurrency.AsyncThrowingFilterSequence<Self> {
    return AsyncThrowingFilterSequence(self, isIncluded: isIncluded)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingFilterSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let isIncluded: (_Concurrency.AsyncThrowingFilterSequence<Base>.Element) async throws -> Swift.Bool
  @usableFromInline
  internal init(_ base: Base, isIncluded: @escaping (Base.Element) async throws -> Swift.Bool)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFilterSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias Failure = any Swift.Error
  public typealias AsyncIterator = _Concurrency.AsyncThrowingFilterSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let isIncluded: (Base.Element) async throws -> Swift.Bool
    @usableFromInline
    internal var finished: Swift.Bool
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, isIncluded: @escaping (Base.Element) async throws -> Swift.Bool)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async throws -> Base.Element? {
      while !finished {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        do {
          if try await isIncluded(element) {
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }

      return nil
    }
    #else
    @inlinable public mutating func next() async throws -> Base.Element? {
      while !finished {
        guard let element = try await baseIterator.next() else {
          return nil
        }
        do {
          if try await isIncluded(element) {
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }

      return nil
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> Base.Element? {
      while !finished {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }
        do {
          if try await isIncluded(element) {
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }

      return nil
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> Base.Element? {
      while !finished {
        guard let element = try await baseIterator.next(isolation: actor) else {
          return nil
        }
        do {
          if try await isIncluded(element) {
            return element
          }
        } catch {
          finished = true
          throw error
        }
      }

      return nil
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Base.Element
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingFilterSequence<Base>.Failure
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingFilterSequence<Base>.Failure
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingFilterSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), isIncluded: isIncluded)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingFilterSequence<Base>.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingFilterSequence<Base>.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFilterSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFilterSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async throws -> SegmentOfResult) -> _Concurrency.AsyncThrowingFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : _Concurrency.AsyncSequence {
    return AsyncThrowingFlatMapSequence(self, transform: transform)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingFlatMapSequence<Base, SegmentOfResult> where Base : _Concurrency.AsyncSequence, SegmentOfResult : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> SegmentOfResult
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> SegmentOfResult)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFlatMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = SegmentOfResult.Element
  public typealias Failure = any Swift.Error
  public typealias AsyncIterator = _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> SegmentOfResult
    @usableFromInline
    internal var currentIterator: SegmentOfResult.AsyncIterator?
    @usableFromInline
    internal var finished: Swift.Bool
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> SegmentOfResult)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async throws -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
             
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next() else {
            return nil
          }
          let segment: SegmentOfResult
          do {
            segment = try await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            currentIterator = nil
            throw error
          }
        }
      }
      return nil
    }
    #else
    @inlinable public mutating func next() async throws -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
             
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next() else {
            return nil
          }
          let segment: SegmentOfResult
          do {
            segment = try await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next() else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            currentIterator = nil
            throw error
          }
        }
      }
      return nil
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next(isolation: actor) else {
              currentIterator = nil
              continue
            }
             
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next(isolation: actor) else {
            return nil
          }
          let segment: SegmentOfResult
          do {
            segment = try await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next(isolation: actor) else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            currentIterator = nil
            throw error
          }
        }
      }
      return nil
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> SegmentOfResult.Element? {
      while !finished {
        if var iterator = currentIterator {
          do {
            guard let element = try await iterator.next(isolation: actor) else {
              currentIterator = nil
              continue
            }
             
            currentIterator = iterator
            return element
          } catch {
            finished = true
            throw error
          }
        } else {
          guard let item = try await baseIterator.next(isolation: actor) else {
            return nil
          }
          let segment: SegmentOfResult
          do {
            segment = try await transform(item)
            var iterator = segment.makeAsyncIterator()
            guard let element = try await iterator.next(isolation: actor) else {
              currentIterator = nil
              continue
            }
            currentIterator = iterator
            return element
          } catch {
            finished = true
            currentIterator = nil
            throw error
          }
        }
      }
      return nil
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = SegmentOfResult.Element
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Failure
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Failure
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFlatMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, SegmentOfResult : Swift.Sendable, Base.Element : Swift.Sendable, SegmentOfResult.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingFlatMapSequence.Iterator : @unchecked Swift.Sendable where SegmentOfResult : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable, SegmentOfResult.AsyncIterator : Swift.Sendable, SegmentOfResult.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func map<Transformed>(_ transform: @escaping @Sendable (Self.Element) async throws -> Transformed) -> _Concurrency.AsyncThrowingMapSequence<Self, Transformed> {
    return AsyncThrowingMapSequence(self, transform: transform)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingMapSequence<Base, Transformed> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let transform: (Base.Element) async throws -> Transformed
  @usableFromInline
  internal init(_ base: Base, transform: @escaping (Base.Element) async throws -> Transformed)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingMapSequence : _Concurrency.AsyncSequence {
  public typealias Element = Transformed
  public typealias Failure = any Swift.Error
  public typealias AsyncIterator = _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let transform: (Base.Element) async throws -> Transformed
    @usableFromInline
    internal var finished: Swift.Bool
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> Transformed)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async throws -> Transformed? {
      guard !finished, let element = try await baseIterator.next() else {
        return nil
      }
      do {
        return try await transform(element)
      } catch {
        finished = true
        throw error   
      }
    }
    #else
    @inlinable public mutating func next() async throws -> Transformed? {
      guard !finished, let element = try await baseIterator.next() else {
        return nil
      }
      do {
        return try await transform(element)
      } catch {
        finished = true
        throw error   
      }
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> Transformed? {
      guard !finished, let element = try await baseIterator.next(isolation: actor) else {
        return nil
      }
      do {
        return try await transform(element)
      } catch {
        finished = true
        throw error   
      }
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> Transformed? {
      guard !finished, let element = try await baseIterator.next(isolation: actor) else {
        return nil
      }
      do {
        return try await transform(element)
      } catch {
        finished = true
        throw error   
      }
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Transformed
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Failure
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Failure
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Iterator {
    return Iterator(base.makeAsyncIterator(), transform: transform)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingMapSequence<Base, Transformed>.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingMapSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Transformed : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingMapSequence.Iterator : @unchecked Swift.Sendable where Transformed : Swift.Sendable, Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  @preconcurrency @inlinable public __consuming func prefix(while predicate: @escaping @Sendable (Self.Element) async throws -> Swift.Bool) rethrows -> _Concurrency.AsyncThrowingPrefixWhileSequence<Self> {
    return AsyncThrowingPrefixWhileSequence(self, predicate: predicate)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingPrefixWhileSequence<Base> where Base : _Concurrency.AsyncSequence {
  @usableFromInline
  internal let base: Base
  @usableFromInline
  internal let predicate: (Base.Element) async throws -> Swift.Bool
  @usableFromInline
  internal init(_ base: Base, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingPrefixWhileSequence : _Concurrency.AsyncSequence {
  public typealias Element = Base.Element
  public typealias Failure = any Swift.Error
  public typealias AsyncIterator = _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var predicateHasFailed: Swift.Bool
    @usableFromInline
    internal var baseIterator: Base.AsyncIterator
    @usableFromInline
    internal let predicate: (Base.Element) async throws -> Swift.Bool
    @usableFromInline
    internal init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async throws -> Swift.Bool)
    #if compiler(>=5.3) && $NoncopyableGenerics
    @inlinable public mutating func next() async throws -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next() {
        do { 
          if try await predicate(nextElement) {
            return nextElement
          } else {
            predicateHasFailed = true
          }
        } catch {
          predicateHasFailed = true
          throw error
        }
      }
      return nil
    }
    #else
    @inlinable public mutating func next() async throws -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next() {
        do { 
          if try await predicate(nextElement) {
            return nextElement
          } else {
            predicateHasFailed = true
          }
        } catch {
          predicateHasFailed = true
          throw error
        }
      }
      return nil
    }
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next(isolation: actor) {
        do { 
          if try await predicate(nextElement) {
            return nextElement
          } else {
            predicateHasFailed = true
          }
        } catch {
          predicateHasFailed = true
          throw error
        }
      }
      return nil
    }
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    @inlinable public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws -> Base.Element? {
      if !predicateHasFailed, let nextElement = try await baseIterator.next(isolation: actor) {
        do { 
          if try await predicate(nextElement) {
            return nextElement
          } else {
            predicateHasFailed = true
          }
        } catch {
          predicateHasFailed = true
          throw error
        }
      }
      return nil
    }
    #endif
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Element = Base.Element
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Failure
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Failure
    #endif
  }
  @inlinable public __consuming func makeAsyncIterator() -> _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Iterator {
    return Iterator(base.makeAsyncIterator(), predicate: predicate)
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = _Concurrency.AsyncThrowingPrefixWhileSequence<Base>.Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingPrefixWhileSequence : @unchecked Swift.Sendable where Base : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingPrefixWhileSequence.Iterator : @unchecked Swift.Sendable where Base.AsyncIterator : Swift.Sendable, Base.Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol GlobalActor {
  associatedtype ActorType : _Concurrency.Actor
  static var shared: Self.ActorType { get }
  static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor { get }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.GlobalActor {
  public static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public var globalConcurrentExecutor: any _Concurrency.TaskExecutor {
  get
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@globalActor final public actor MainActor : _Concurrency.GlobalActor {
  public static let shared: _Concurrency.MainActor
  @inlinable nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get {
    #if compiler(>=5.5) && $BuiltinBuildMainExecutor
    return UnownedSerialExecutor(Builtin.buildMainActorExecutorRef())
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  }
  @inlinable public static var sharedUnownedExecutor: _Concurrency.UnownedSerialExecutor {
    get {
    #if compiler(>=5.5) && $BuiltinBuildMainExecutor
    return UnownedSerialExecutor(Builtin.buildMainActorExecutorRef())
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  }
  @inlinable nonisolated final public func enqueue(_ job: _Concurrency.UnownedJob) {
    _enqueueOnMain(job)
  }
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ActorType = _Concurrency.MainActor
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.MainActor {
  @usableFromInline
  internal static func run<T>(resultType: T.Type = T.self, body: @_Concurrency.MainActor @Sendable () throws -> T) async rethrows -> T
  @_alwaysEmitIntoClient public static func run<T>(resultType: T.Type = T.self, body: @_Concurrency.MainActor @Sendable () throws -> T) async rethrows -> T where T : Swift.Sendable {
    return try await body()
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.MainActor {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_alwaysEmitIntoClient @_unavailableFromAsync(message: "await the call to the @MainActor closure directly") public static func assumeIsolated<T>(_ operation: @_Concurrency.MainActor () throws -> T, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) rethrows -> T where T : Swift.Sendable {
    typealias YesActor = @MainActor () throws -> T
    typealias NoActor = () throws -> T

     
     
    let executor: Builtin.Executor = Self.shared.unownedExecutor.executor
    guard _taskIsCurrentExecutor(executor) else {
       
      fatalError("Incorrect actor executor assumption; Expected same executor as \(self).", file: file, line: line)
    }

    #if $TypedThrows
     
    return try withoutActuallyEscaping(operation) {
      (_ fn: @escaping YesActor) throws -> T in
      let rawFn = unsafeBitCast(fn, to: NoActor.self)
      return try rawFn()
    }
    #else
    fatalError("unsupported compiler")
    #endif
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  @_silgen_name("$sScM14assumeIsolated_4file4linexxyKScMYcXE_s12StaticStringVSutKlFZ")
  internal static func __abi__assumeIsolated<T>(_ operation: @_Concurrency.MainActor () throws -> T, _ file: Swift.StaticString, _ line: Swift.UInt) rethrows -> T where T : Swift.Sendable
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_job_run")
@usableFromInline
internal func _swiftJobRun(_ job: _Concurrency.UnownedJob, _ executor: _Concurrency.UnownedSerialExecutor)
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@_silgen_name("swift_job_run_on_task_executor")
@usableFromInline
internal func _swiftJobRunOnTaskExecutor(_ job: _Concurrency.UnownedJob, _ executor: _Concurrency.UnownedTaskExecutor)
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@_silgen_name("swift_job_run_on_serial_and_task_executor")
@usableFromInline
internal func _swiftJobRunOnTaskExecutor(_ job: _Concurrency.UnownedJob, _ serialExecutor: _Concurrency.UnownedSerialExecutor, _ taskExecutor: _Concurrency.UnownedTaskExecutor)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnownedJob : Swift.Sendable {
  private var context: Builtin.Job
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  @usableFromInline
  internal init(context: Builtin.Job)
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init(_ job: __owned _Concurrency.Job)
  #endif
  #if compiler(>=5.3) && $MoveOnly
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init(_ job: __owned _Concurrency.ExecutorJob)
  #endif
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var priority: _Concurrency.JobPriority {
    get
  }
  @available(*, deprecated, renamed: "ExecutorJob.runSynchronously(on:)")
  @_alwaysEmitIntoClient @inlinable public func _runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
    _swiftJobRun(self, executor)
  }
  @_alwaysEmitIntoClient @inlinable public func runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
    _swiftJobRun(self, executor)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @inlinable public func runSynchronously(on executor: _Concurrency.UnownedTaskExecutor) {
    _swiftJobRunOnTaskExecutor(self, executor)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @inlinable public func runSynchronously(isolatedTo serialExecutor: _Concurrency.UnownedSerialExecutor, taskExecutor: _Concurrency.UnownedTaskExecutor) {
    _swiftJobRunOnTaskExecutor(self, serialExecutor, taskExecutor)
  }
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.UnownedJob : Swift.CustomStringConvertible {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var description: Swift.String {
    get
  }
}
#if compiler(>=5.3) && $MoveOnly
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@available(*, deprecated, renamed: "ExecutorJob")
@frozen @_moveOnly public struct Job : Swift.Sendable {
  internal var context: Builtin.Job
  @usableFromInline
  internal init(context: __owned Builtin.Job)
  public init(_ job: _Concurrency.UnownedJob)
  public init(_ job: __owned _Concurrency.ExecutorJob)
  public var priority: _Concurrency.JobPriority {
    get
  }
  public var description: Swift.String {
    get
  }
}
#endif
#if compiler(>=5.3) && $MoveOnly
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.Job {
  @_alwaysEmitIntoClient @inlinable public __consuming func runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
    _swiftJobRun(UnownedJob(self), executor)
  }
}
#endif
#if compiler(>=5.3) && $MoveOnly
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen @_moveOnly public struct ExecutorJob : Swift.Sendable {
  internal var context: Builtin.Job
  @usableFromInline
  internal init(context: __owned Builtin.Job)
  public init(_ job: _Concurrency.UnownedJob)
  public init(_ job: __owned _Concurrency.Job)
  public var priority: _Concurrency.JobPriority {
    get
  }
  public var description: Swift.String {
    get
  }
}
#endif
#if compiler(>=5.3) && $MoveOnly
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.ExecutorJob {
  @_alwaysEmitIntoClient @inlinable public __consuming func runSynchronously(on executor: _Concurrency.UnownedSerialExecutor) {
    _swiftJobRun(UnownedJob(self), executor)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @inlinable public __consuming func runSynchronously(on executor: _Concurrency.UnownedTaskExecutor) {
    _swiftJobRunOnTaskExecutor(UnownedJob(self), executor)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @inlinable public __consuming func runSynchronously(isolatedTo serialExecutor: _Concurrency.UnownedSerialExecutor, taskExecutor: _Concurrency.UnownedTaskExecutor) {
    _swiftJobRunOnTaskExecutor(UnownedJob(self), serialExecutor, taskExecutor)
  }
}
#endif
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen public struct JobPriority : Swift.Sendable {
  public typealias RawValue = Swift.UInt8
  public var rawValue: _Concurrency.JobPriority.RawValue
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.TaskPriority {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init?(_ p: _Concurrency.JobPriority)
  #else
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init?(_ p: _Concurrency.JobPriority)
  #endif
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.JobPriority : Swift.Equatable {
  public static func == (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
  public static func != (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.JobPriority : Swift.Comparable {
  public static func < (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
  public static func <= (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
  public static func > (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
  public static func >= (lhs: _Concurrency.JobPriority, rhs: _Concurrency.JobPriority) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct UnsafeContinuation<T, E> : Swift.Sendable where E : Swift.Error {
  @usableFromInline
  internal var context: Builtin.RawUnsafeContinuation
  @_alwaysEmitIntoClient internal init(_ context: Builtin.RawUnsafeContinuation) {
    self.context = context
  }
  @_alwaysEmitIntoClient public func resume(returning value: __owned T) where E == Swift.Never {
    #if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeNonThrowingContinuationReturning(context, value)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  @_alwaysEmitIntoClient public func resume(returning value: __owned T) {
    #if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeThrowingContinuationReturning(context, value)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
  @_alwaysEmitIntoClient public func resume(throwing error: __owned E) {
    #if compiler(>=5.5) && $BuiltinContinuation
    Builtin.resumeThrowingContinuationThrowing(context, error)
    #else
    fatalError("Swift compiler is incompatible with this SDK version")
    #endif
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeContinuation {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func resume<Er>(with result: Swift.Result<T, Er>) where E == any Swift.Error, Er : Swift.Error {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  #else
  @_alwaysEmitIntoClient public func resume<Er>(with result: Swift.Result<T, Er>) where E == any Swift.Error, Er : Swift.Error {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public func resume(with result: Swift.Result<T, E>) {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  #else
  @_alwaysEmitIntoClient public func resume(with result: Swift.Result<T, E>) {
    switch result {
      case .success(let val):
        self.resume(returning: val)
      case .failure(let err):
        self.resume(throwing: err)
    }
  }
  #endif
  @_alwaysEmitIntoClient public func resume() where T == () {
    self.resume(returning: ())
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeContinuation<T>(_ continuation: _Concurrency.UnsafeContinuation<T, Swift.Never>, _ value: __owned T) {
  continuation.resume(returning: value)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeThrowingContinuation<T>(_ continuation: _Concurrency.UnsafeContinuation<T, any Swift.Error>, _ value: __owned T) {
  continuation.resume(returning: value)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func _resumeUnsafeThrowingContinuationWithError<T>(_ continuation: _Concurrency.UnsafeContinuation<T, any Swift.Error>, _ error: __owned any Swift.Error) {
  continuation.resume(throwing: error)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @_alwaysEmitIntoClient public func withUnsafeContinuation<T>(_ fn: (_Concurrency.UnsafeContinuation<T, Swift.Never>) -> Swift.Void) async -> T {
  return await Builtin.withUnsafeContinuation {
    fn(UnsafeContinuation<T, Never>($0))
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @_alwaysEmitIntoClient public func withUnsafeThrowingContinuation<T>(_ fn: (_Concurrency.UnsafeContinuation<T, any Swift.Error>) -> Swift.Void) async throws -> T {
  return try await Builtin.withUnsafeThrowingContinuation {
    fn(UnsafeContinuation<T, Error>($0))
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient public func _abiEnableAwaitContinuation() {
  fatalError("never use this function")
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  @available(*, deprecated, message: "Task.Priority has been removed; use TaskPriority")
  public typealias Priority = _Concurrency.TaskPriority
  @available(*, deprecated, message: "Task.Handle has been removed; use Task")
  public typealias Handle = _Concurrency.Task
  @available(*, deprecated, message: "Task.CancellationError has been removed; use CancellationError")
  @_alwaysEmitIntoClient public static func CancellationError() -> _Concurrency.CancellationError {
    return _Concurrency.CancellationError()
  }
  @available(*, deprecated, renamed: "yield()")
  @_alwaysEmitIntoClient public static func suspend() async {
    await yield()
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority {
  @available(*, deprecated, message: "unspecified priority will be removed; use nil")
  @_alwaysEmitIntoClient public static var unspecified: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x00)
  }
  }
  @available(*, deprecated, message: "userInteractive priority will be removed")
  @_alwaysEmitIntoClient public static var userInteractive: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x21)
  }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, renamed: "withTaskCancellationHandler(operation:onCancel:)")
@_alwaysEmitIntoClient public func withTaskCancellationHandler<T>(handler: @Sendable () -> Swift.Void, operation: () async throws -> T) async rethrows -> T {
  try await withTaskCancellationHandler(operation: operation, onCancel: handler)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  @available(*, deprecated, message: "`Task.withCancellationHandler` has been replaced by `withTaskCancellationHandler` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func withCancellationHandler<T>(handler: @Sendable () -> Swift.Void, operation: () async throws -> T) async rethrows -> T {
    try await withTaskCancellationHandler(operation: operation, onCancel: handler)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == any Swift.Error {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @available(*, deprecated, message: "`Task.runDetached` was replaced by `Task.detached` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func runDetached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
    detached(priority: priority, operation: operation)
  }
  #else
  @discardableResult
  @available(*, deprecated, message: "`Task.runDetached` was replaced by `Task.detached` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func runDetached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
    detached(priority: priority, operation: operation)
  }
  #endif
}
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func detach<T>(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  Task.detached(priority: priority, operation: operation)
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func detach<T>(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  Task.detached(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func detach<T>(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  Task.detached(priority: priority, operation: operation)
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func detach<T>(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  Task.detached(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func asyncDetached<T>(priority: _Concurrency.TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  return Task.detached(priority: priority, operation: operation)
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func asyncDetached<T>(priority: _Concurrency.TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  return Task.detached(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func asyncDetached<T>(priority: _Concurrency.TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  return Task.detached(priority: priority, operation: operation)
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient public func asyncDetached<T>(priority: _Concurrency.TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  return Task.detached(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient public func async<T>(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  .init(priority: priority, operation: operation)
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient public func async<T>(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> _Concurrency.Task<T, Swift.Never> where T : Swift.Sendable {
  .init(priority: priority, operation: operation)
}
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient public func async<T>(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  .init(priority: priority, operation: operation)
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient public func async<T>(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> _Concurrency.Task<T, any Swift.Error> where T : Swift.Sendable {
  .init(priority: priority, operation: operation)
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  @available(*, deprecated, message: "`Task.Group` was replaced by `ThrowingTaskGroup` and `TaskGroup` and will be removed shortly.")
  public typealias Group<TaskResult> = _Concurrency.ThrowingTaskGroup<TaskResult, any Swift.Error> where TaskResult : Swift.Sendable
  @available(*, deprecated, message: "`Task.withGroup` was replaced by `withThrowingTaskGroup` and `withTaskGroup` and will be removed shortly.")
  @_alwaysEmitIntoClient public static func withGroup<TaskResult, BodyResult>(resultType: TaskResult.Type, returning returnType: BodyResult.Type = BodyResult.self, body: (inout _Concurrency.Task<Success, Failure>.Group<TaskResult>) async throws -> BodyResult) async rethrows -> BodyResult where TaskResult : Swift.Sendable {
    try await withThrowingTaskGroup(of: resultType) { group in
      try await body(&group)
    }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient public func get() async throws -> Success {
    return try await value
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, message: "getResult() has been replaced by .result")
  @_alwaysEmitIntoClient public func getResult() async -> Swift.Result<Success, Failure> {
    return await result
  }
  #else
  @available(*, deprecated, message: "getResult() has been replaced by .result")
  @_alwaysEmitIntoClient public func getResult() async -> Swift.Result<Success, Failure> {
    return await result
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient public func get() async -> Success {
    return await value
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskGroup {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func add(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) async -> Swift.Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      await operation()
    }
  }
  #else
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func add(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) async -> Swift.Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      await operation()
    }
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawn(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #else
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawn(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawnUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #else
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawnUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func async(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #else
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func async(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func asyncUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #else
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func asyncUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.ThrowingTaskGroup {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func add(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) async -> Swift.Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      try await operation()
    }
  }
  #else
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func add(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) async -> Swift.Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      try await operation()
    }
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawn(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #else
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawn(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawnUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #else
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func spawnUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func async(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #else
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func async(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    addTask(priority: priority, operation: operation)
  }
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func asyncUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #else
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient public mutating func asyncUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "please use UnsafeContinuation<..., Error>")
public typealias UnsafeThrowingContinuation<T> = _Concurrency.UnsafeContinuation<T, any Swift.Error>
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, renamed: "UnownedJob")
public typealias PartialAsyncTask = _Concurrency.UnownedJob
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct Task<Success, Failure> : Swift.Sendable where Success : Swift.Sendable, Failure : Swift.Error {
  @usableFromInline
  internal let _task: Builtin.NativeObject
  @_alwaysEmitIntoClient internal init(_ task: Builtin.NativeObject) {
    self._task = task
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  public var value: Success {
    get async throws
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  public var result: Swift.Result<Success, Failure> {
    get async
  }
  #else
  public var result: Swift.Result<Success, Failure> {
    get async
  }
  #endif
  public func cancel()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  public var value: Success {
    get async
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task : Swift.Equatable {
  public static func == (lhs: _Concurrency.Task<Success, Failure>, rhs: _Concurrency.Task<Success, Failure>) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct TaskPriority : Swift.RawRepresentable, Swift.Sendable {
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8
  public init(rawValue: Swift.UInt8)
  public static let high: _Concurrency.TaskPriority
  @_alwaysEmitIntoClient public static var medium: _Concurrency.TaskPriority {
    get {
    .init(rawValue: 0x15)
  }
  }
  public static let low: _Concurrency.TaskPriority
  public static let userInitiated: _Concurrency.TaskPriority
  public static let utility: _Concurrency.TaskPriority
  public static let background: _Concurrency.TaskPriority
  @available(*, deprecated, renamed: "medium")
  public static let `default`: _Concurrency.TaskPriority
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Equatable {
  public static func == (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func != (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Comparable {
  public static func < (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func <= (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func > (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
  public static func >= (lhs: _Concurrency.TaskPriority, rhs: _Concurrency.TaskPriority) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension _Concurrency.TaskPriority : Swift.CustomStringConvertible {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var description: Swift.String {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskPriority : Swift.Codable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static var currentPriority: _Concurrency.TaskPriority {
    get
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var basePriority: _Concurrency.TaskPriority? {
    get
  }
  #else
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var basePriority: _Concurrency.TaskPriority? {
    get
  }
  #endif
}
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func taskCreateFlags(priority: _Concurrency.TaskPriority?, isChildTask: Swift.Bool, copyTaskLocals: Swift.Bool, inheritContext: Swift.Bool, enqueueJob: Swift.Bool, addPendingGroupTaskUnconditionally: Swift.Bool, isDiscardingTask: Swift.Bool) -> Swift.Int {
  var bits = 0
  bits |= (bits & ~0xFF) | Int(priority?.rawValue ?? 0)
  if isChildTask {
    bits |= 1 << 8
  }
  if copyTaskLocals {
    bits |= 1 << 10
  }
  if inheritContext {
    bits |= 1 << 11
  }
  if enqueueJob {
    bits |= 1 << 12
  }
  if addPendingGroupTaskUnconditionally {
    bits |= 1 << 13
  }
  if isDiscardingTask {
    bits |= 1 << 14
  }
  return bits
}
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient internal func taskCreateFlags(priority: _Concurrency.TaskPriority?, isChildTask: Swift.Bool, copyTaskLocals: Swift.Bool, inheritContext: Swift.Bool, enqueueJob: Swift.Bool, addPendingGroupTaskUnconditionally: Swift.Bool, isDiscardingTask: Swift.Bool) -> Swift.Int {
  var bits = 0
  bits |= (bits & ~0xFF) | Int(priority?.rawValue ?? 0)
  if isChildTask {
    bits |= 1 << 8
  }
  if copyTaskLocals {
    bits |= 1 << 10
  }
  if inheritContext {
    bits |= 1 << 11
  }
  if enqueueJob {
    bits |= 1 << 12
  }
  if addPendingGroupTaskUnconditionally {
    bits |= 1 << 13
  }
  if isDiscardingTask {
    bits |= 1 << 14
  }
  return bits
}
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @isolated(any) @Sendable () async -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == any Swift.Error {
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @isolated(any) @Sendable () async throws -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public init(priority: _Concurrency.TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> Success) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    self._task = task
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Failure == any Swift.Error {
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    let (task, _) = Builtin.createTask(flags: flags,
                                       initialSerialExecutor:
                                         builtinSerialExecutor,
                                       operation: operation)
#else
    let (task, _) = Builtin.createAsyncTask(flags, operation)
#endif

    return Task(task)
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static func yield() async
}
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func withUnsafeCurrentTask<T>(body: (_Concurrency.UnsafeCurrentTask?) throws -> T) rethrows -> T
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func withUnsafeCurrentTask<T>(body: (_Concurrency.UnsafeCurrentTask?) throws -> T) rethrows -> T
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func withUnsafeCurrentTask<T>(body: (_Concurrency.UnsafeCurrentTask?) async throws -> T) async rethrows -> T
#else
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func withUnsafeCurrentTask<T>(body: (_Concurrency.UnsafeCurrentTask?) async throws -> T) async rethrows -> T
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct UnsafeCurrentTask {
  public var isCancelled: Swift.Bool {
    get
  }
  public var priority: _Concurrency.TaskPriority {
    get
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var basePriority: _Concurrency.TaskPriority {
    get
  }
  public func cancel()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension _Concurrency.UnsafeCurrentTask : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeCurrentTask : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.UnsafeCurrentTask : Swift.Equatable {
  public static func == (lhs: _Concurrency.UnsafeCurrentTask, rhs: _Concurrency.UnsafeCurrentTask) -> Swift.Bool
}
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_getCurrent")
public func _getCurrentAsyncTask() -> Builtin.NativeObject?
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_getCurrent")
public func _getCurrentAsyncTask() -> Builtin.NativeObject?
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueGlobal")
@usableFromInline
internal func _enqueueJobGlobal(_ task: Builtin.Job)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueGlobalWithDelay")
@usableFromInline
internal func _enqueueJobGlobalWithDelay(_ delay: Swift.UInt64, _ task: Builtin.Job)
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_silgen_name("swift_task_enqueueGlobalWithDeadline")
@usableFromInline
internal func _enqueueJobGlobalWithDeadline(_ seconds: Swift.Int64, _ nanoseconds: Swift.Int64, _ toleranceSec: Swift.Int64, _ toleranceNSec: Swift.Int64, _ clock: Swift.Int32, _ task: Builtin.Job)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_asyncMainDrainQueue")
internal func _asyncMainDrainQueue() -> Swift.Never
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_getMainExecutor")
internal func _getMainExecutor() -> Builtin.Executor
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@usableFromInline
internal func _getGenericSerialExecutor() -> Builtin.Executor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@preconcurrency internal func _runAsyncMain(_ asyncFun: @escaping @Sendable () async throws -> ())
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_future_wait")
public func _taskFutureGet<T>(_ task: Builtin.NativeObject) async -> T
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_future_wait_throwing")
public func _taskFutureGetThrowing<T>(_ task: Builtin.NativeObject) async throws -> T
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_cancel")
public func _taskCancel(_ task: Builtin.NativeObject)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_isCancelled")
@usableFromInline
internal func _taskIsCancelled(_ task: Builtin.NativeObject) -> Swift.Bool
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_isCurrentExecutor")
internal func _taskIsCurrentExecutor(_ executor: Builtin.Executor) -> Swift.Bool
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportUnexpectedExecutor")
internal func _reportUnexpectedExecutor(_ _filenameStart: Builtin.RawPointer, _ _filenameLength: Builtin.Word, _ _filenameIsASCII: Builtin.Int1, _ _line: Builtin.Word, _ _executor: Builtin.Executor)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_alwaysEmitIntoClient internal func _runTaskForBridgedAsyncMethod(@_inheritActorContext _ body: __owned @escaping @Sendable () async -> Swift.Void) {
#if compiler(>=5.6)
  Task(operation: body)
#else
  Task<Int, Error> {
    await body()
    return 0
  }
#endif
}
#if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
#if $NoncopyableGenerics
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func withTaskExecutorPreference<T, Failure>(_ taskExecutor: (any _Concurrency.TaskExecutor)?, isolation: isolated (any _Concurrency.Actor)? = #isolation, operation: () async throws(Failure) -> T) async throws(Failure) -> T where Failure : Swift.Error
#else
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func withTaskExecutorPreference<T, Failure>(_ taskExecutor: (any _Concurrency.TaskExecutor)?, isolation: isolated (any _Concurrency.Actor)? = #isolation, operation: () async throws(Failure) -> T) async throws(Failure) -> T where Failure : Swift.Error
#endif
#endif
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@_silgen_name("$ss26withTaskExecutorPreference_9operationxSch_pSg_xyYaYbKXEtYaKs8SendableRzlF")
@_unsafeInheritExecutor public func __abi__withTaskExecutorPreference<T>(_ taskExecutor: (any _Concurrency.TaskExecutor)?, operation: @Sendable () async throws -> T) async rethrows -> T where T : Swift.Sendable
#else
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@_silgen_name("$ss26withTaskExecutorPreference_9operationxSch_pSg_xyYaYbKXEtYaKs8SendableRzlF")
@_unsafeInheritExecutor public func __abi__withTaskExecutorPreference<T>(_ taskExecutor: (any _Concurrency.TaskExecutor)?, operation: @Sendable () async throws -> T) async rethrows -> T where T : Swift.Sendable
#endif
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public init(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) {
    guard let taskExecutor else {
      self = Self.init(priority: priority, operation: operation)
      return
    }
    #if $BuiltinCreateAsyncTaskWithExecutor
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

    let (task, _) = Builtin.createAsyncTaskWithExecutor(
      flags, executorBuiltin, operation)
    self._task = task
    #else
    fatalError("Unsupported Swift compiler, missing support for BuiltinCreateAsyncTaskWithExecutor")
    #endif
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public init(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) {
    guard let taskExecutor else {
      self = Self.init(priority: priority, operation: operation)
      return
    }
    #if $BuiltinCreateAsyncTaskWithExecutor
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

    let (task, _) = Builtin.createAsyncTaskWithExecutor(
      flags, executorBuiltin, operation)
    self._task = task
    #else
    fatalError("Unsupported Swift compiler, missing support for BuiltinCreateAsyncTaskWithExecutor")
    #endif
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.Task where Failure == any Swift.Error {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public init(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) {
    guard let taskExecutor else {
      self = Self.init(priority: priority, operation: operation)
      return
    }
    #if $BuiltinCreateAsyncTaskWithExecutor
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor
    let (task, _) = Builtin.createAsyncTaskWithExecutor(
      flags, executorBuiltin, operation)
    self._task = task
    #else
    fatalError("Unsupported Swift compiler, missing support for $BuiltinCreateAsyncTaskWithExecutor")
    #endif
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public init(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) {
    guard let taskExecutor else {
      self = Self.init(priority: priority, operation: operation)
      return
    }
    #if $BuiltinCreateAsyncTaskWithExecutor
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: true,
      inheritContext: true, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor
    let (task, _) = Builtin.createAsyncTaskWithExecutor(
      flags, executorBuiltin, operation)
    self._task = task
    #else
    fatalError("Unsupported Swift compiler, missing support for $BuiltinCreateAsyncTaskWithExecutor")
    #endif
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.Task where Failure == Swift.Never {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) -> _Concurrency.Task<Success, Failure> {
    guard let taskExecutor else {
      return Self.detached(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskWithExecutor
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    let executorBuiltin: Builtin.Executor =
        taskExecutor.asUnownedTaskExecutor().executor
    let (task, _) = Builtin.createAsyncTaskWithExecutor(
      flags, executorBuiltin, operation)

    return Task(task)
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) -> _Concurrency.Task<Success, Failure> {
    guard let taskExecutor else {
      return Self.detached(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskWithExecutor
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    let executorBuiltin: Builtin.Executor =
        taskExecutor.asUnownedTaskExecutor().executor
    let (task, _) = Builtin.createAsyncTaskWithExecutor(
      flags, executorBuiltin, operation)

    return Task(task)
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.Task where Failure == any Swift.Error {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
    guard let taskExecutor else {
      return Self.detached(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskWithExecutor
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    let executorBuiltin: Builtin.Executor =
        taskExecutor.asUnownedTaskExecutor().executor
    let (task, _) = Builtin.createAsyncTaskWithExecutor(
      flags, executorBuiltin, operation)

    return Task(task)
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @discardableResult
  @_alwaysEmitIntoClient public static func detached(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> _Concurrency.Task<Success, Failure> {
    guard let taskExecutor else {
      return Self.detached(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskWithExecutor
     
    let flags = taskCreateFlags(
      priority: priority, isChildTask: false, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    let executorBuiltin: Builtin.Executor =
        taskExecutor.asUnownedTaskExecutor().executor
    let (task, _) = Builtin.createAsyncTaskWithExecutor(
      flags, executorBuiltin, operation)

    return Task(task)
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.UnsafeCurrentTask {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var unownedTaskExecutor: _Concurrency.UnownedTaskExecutor? {
    get
  }
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var unownedTaskExecutor: _Concurrency.UnownedTaskExecutor? {
    get
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@usableFromInline
internal func _getUndefinedTaskExecutor() -> Builtin.Executor
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@backDeployed(before: macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4)
@_unsafeInheritExecutor public func withTaskCancellationHandler<T>(operation: () async throws -> T, onCancel handler: @Sendable () -> Swift.Void) async rethrows -> T {
   
   
  let record = _taskAddCancellationHandler(handler: handler)
  defer { _taskRemoveCancellationHandler(record: record) }

  return try await operation()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task {
  @_transparent public var isCancelled: Swift.Bool {
    @_transparent get {
    _taskIsCancelled(_task)
  }
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static func checkCancellation() throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct CancellationError : Swift.Error {
  public init()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_addCancellationHandler")
internal func _taskAddCancellationHandler(handler: () -> Swift.Void) -> Swift.UnsafeRawPointer
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_removeCancellationHandler")
internal func _taskRemoveCancellationHandler(record: Swift.UnsafeRawPointer)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("$ss13withTaskGroup2of9returning4bodyq_xm_q_mq_ScGyxGzYaXEtYar0_lF")
@_unsafeInheritExecutor @inlinable public func withTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.TaskGroup<ChildTaskResult>) async -> GroupResult) async -> GroupResult where ChildTaskResult : Swift.Sendable {
  #if compiler(>=5.5) && $BuiltinTaskGroupWithArgument

  let _group = Builtin.createTaskGroup(ChildTaskResult.self)
  var group = TaskGroup<ChildTaskResult>(group: _group)

   
  let result = await body(&group)

   
  await group.awaitAllRemainingTasks()

  Builtin.destroyTaskGroup(_group)
  return result

  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("$ss21withThrowingTaskGroup2of9returning4bodyq_xm_q_mq_Scgyxs5Error_pGzYaKXEtYaKr0_lF")
@_unsafeInheritExecutor @inlinable public func withThrowingTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.ThrowingTaskGroup<ChildTaskResult, any Swift.Error>) async throws -> GroupResult) async rethrows -> GroupResult where ChildTaskResult : Swift.Sendable {
  #if compiler(>=5.5) && $BuiltinTaskGroupWithArgument

  let _group = Builtin.createTaskGroup(ChildTaskResult.self)
  var group = ThrowingTaskGroup<ChildTaskResult, Error>(group: _group)

  do {
     
    let result = try await body(&group)

     
    await group.awaitAllRemainingTasks()
    Builtin.destroyTaskGroup(_group)

    return result
  } catch {
    group.cancelAll()

     
    await group.awaitAllRemainingTasks()
    Builtin.destroyTaskGroup(_group)

    throw error
  }

  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct TaskGroup<ChildTaskResult> where ChildTaskResult : Swift.Sendable {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
#if SWIFT_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: false,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false
    )
#else
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)
#endif

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
#if SWIFT_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: false,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false
    )
#else
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)
#endif

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
#if SWIFT_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: false,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false
    )
#else
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)
#endif

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
#if SWIFT_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: false,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)
#else
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)
#endif

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
#if SWIFT_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: false,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)
#else
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)
#endif

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
#if SWIFT_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: false,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)
#else
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)
#endif

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  public mutating func next(isolation: isolated (any _Concurrency.Actor)? = #isolation) async -> ChildTaskResult? {
     
     
    return try! await _taskGroupWaitNext(group: _group)  
  }
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  public mutating func next(isolation: isolated (any _Concurrency.Actor)? = #isolation) async -> ChildTaskResult? {
     
     
    return try! await _taskGroupWaitNext(group: _group)  
  }
  #endif
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_disfavoredOverload public mutating func next() async -> ChildTaskResult?
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_disfavoredOverload public mutating func next() async -> ChildTaskResult?
  #endif
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  @usableFromInline
  internal mutating func awaitAllRemainingTasks(isolation: isolated (any _Concurrency.Actor)? = #isolation) async {
    while let _ = await next(isolation: isolation) {}
  }
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  @usableFromInline
  internal mutating func awaitAllRemainingTasks(isolation: isolated (any _Concurrency.Actor)? = #isolation) async {
    while let _ = await next(isolation: isolation) {}
  }
  #endif
  #endif
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @usableFromInline
  @_silgen_name("$sScG22awaitAllRemainingTasksyyYaF")
  internal mutating func awaitAllRemainingTasks() async
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func waitForAll(isolation: isolated (any _Concurrency.Actor)? = #isolation) async {
    await awaitAllRemainingTasks(isolation: isolation)
  }
  #else
  @_alwaysEmitIntoClient public mutating func waitForAll(isolation: isolated (any _Concurrency.Actor)? = #isolation) async {
    await awaitAllRemainingTasks(isolation: isolation)
  }
  #endif
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension _Concurrency.TaskGroup : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen public struct ThrowingTaskGroup<ChildTaskResult, Failure> where ChildTaskResult : Swift.Sendable, Failure : Swift.Error {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  @usableFromInline
  internal mutating func awaitAllRemainingTasks(isolation: isolated (any _Concurrency.Actor)? = #isolation) async {
    while true {
      do {
        guard let _ = try await next(isolation: isolation) else {
          return
        }
      } catch {}
    }
  }
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  @usableFromInline
  internal mutating func awaitAllRemainingTasks(isolation: isolated (any _Concurrency.Actor)? = #isolation) async {
    while true {
      do {
        guard let _ = try await next(isolation: isolation) else {
          return
        }
      } catch {}
    }
  }
  #endif
  #endif
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @usableFromInline
  internal mutating func awaitAllRemainingTasks() async
  @usableFromInline
  internal mutating func _waitForAll() async throws
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func waitForAll(isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws {
    var firstError: Error? = nil

     
    while !isEmpty {
      do {
        while let _ = try await next() {}
      } catch {
         
        if firstError == nil {
          firstError = error
        }
      }
    }

    if let firstError {
      throw firstError
    }
  }
  #else
  @_alwaysEmitIntoClient public mutating func waitForAll(isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws {
    var firstError: Error? = nil

     
    while !isEmpty {
      do {
        while let _ = try await next() {}
      } catch {
         
        if firstError == nil {
          firstError = error
        }
      }
    }

    if let firstError {
      throw firstError
    }
  }
  #endif
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor
    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  public mutating func next(isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws -> ChildTaskResult? {
    return try await _taskGroupWaitNext(group: _group)
  }
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  public mutating func next(isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws -> ChildTaskResult? {
    return try await _taskGroupWaitNext(group: _group)
  }
  #endif
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_disfavoredOverload public mutating func next() async throws -> ChildTaskResult?
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_disfavoredOverload public mutating func next() async throws -> ChildTaskResult?
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @_silgen_name("$sScg10nextResults0B0Oyxq_GSgyYaKF")
  @usableFromInline
  internal mutating func nextResultForABI() async throws -> Swift.Result<ChildTaskResult, Failure>?
  #else
  @_silgen_name("$sScg10nextResults0B0Oyxq_GSgyYaKF")
  @usableFromInline
  internal mutating func nextResultForABI() async throws -> Swift.Result<ChildTaskResult, Failure>?
  #endif
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func nextResult(isolation: isolated (any _Concurrency.Actor)? = #isolation) async -> Swift.Result<ChildTaskResult, Failure>? {
    return try! await nextResultForABI()
  }
  #else
  @_alwaysEmitIntoClient public mutating func nextResult(isolation: isolated (any _Concurrency.Actor)? = #isolation) async -> Swift.Result<ChildTaskResult, Failure>? {
    return try! await nextResultForABI()
  }
  #endif
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension _Concurrency.ThrowingTaskGroup : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.TaskGroup : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = _Concurrency.TaskGroup<ChildTaskResult>.Iterator
  public typealias Element = ChildTaskResult
  public func makeAsyncIterator() -> _Concurrency.TaskGroup<ChildTaskResult>.Iterator
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ChildTaskResult
    @usableFromInline
    internal var group: _Concurrency.TaskGroup<ChildTaskResult>
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $NoncopyableGenerics
    public mutating func next() async -> _Concurrency.TaskGroup<ChildTaskResult>.Iterator.Element?
    #else
    public mutating func next() async -> _Concurrency.TaskGroup<ChildTaskResult>.Iterator.Element?
    #endif
    public mutating func cancel()
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #endif
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.ThrowingTaskGroup : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator
  public typealias Element = ChildTaskResult
  public func makeAsyncIterator() -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = ChildTaskResult
    @usableFromInline
    internal var group: _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>
    @usableFromInline
    internal var finished: Swift.Bool
    #if compiler(>=5.3) && $NoncopyableGenerics
    public mutating func next() async throws -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator.Element?
    #else
    public mutating func next() async throws -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator.Element?
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Failure) -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator.Element?
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Failure) -> _Concurrency.ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator.Element?
    #endif
    #endif
    public mutating func cancel()
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Failure
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = Failure
    #endif
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_taskGroup_addPending")
@usableFromInline
internal func _taskGroupAddPendingTask(group: Builtin.RawPointer, unconditionally: Swift.Bool) -> Swift.Bool
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_taskGroup_wait_next_throwing")
public func _taskGroupWaitNext<T>(group: Builtin.RawPointer) async throws -> T?
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_taskGroup_wait_next_throwing")
public func _taskGroupWaitNext<T>(group: Builtin.RawPointer) async throws -> T?
#endif
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
@_alwaysEmitIntoClient internal func taskGroupCreateFlags(discardResults: Swift.Bool) -> Swift.Int {
  var bits = 0
  if discardResults {
    bits |= 1 << 8
  }
  return bits
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.TaskGroup {
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> ChildTaskResult) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.ThrowingTaskGroup {
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> ChildTaskResult) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false,
      isDiscardingTask: false)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.DiscardingTaskGroup {
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> Swift.Void) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: true)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: true)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: true)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> Swift.Void) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension _Concurrency.ThrowingDiscardingTaskGroup {
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> Swift.Void) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: true)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: true)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) {
    guard let taskExecutor else {
      return self.addTask(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true,
      isDiscardingTask: true)

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> Swift.Void) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(executorPreference taskExecutor: (any _Concurrency.TaskExecutor)?, priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) -> Swift.Bool {
    guard let taskExecutor else {
      return self.addTaskUnlessCancelled(priority: priority, operation: operation)
    }
    #if $BuiltinCreateAsyncDiscardingTaskInGroupWithExecutor
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

    let executorBuiltin: Builtin.Executor =
      taskExecutor.asUnownedTaskExecutor().executor

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createTask(flags: flags,
                           initialSerialExecutor: builtinSerialExecutor,
                           taskGroup: _group,
                           initialTaskExecutor: executorBuiltin,
                           operation: operation)
    #else
    _ = Builtin.createAsyncDiscardingTaskInGroupWithExecutor(flags, _group, executorBuiltin, operation)
    #endif
    return true
    #else
    fatalError("Unsupported Swift compiler")
    #endif
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@inlinable @_unsafeInheritExecutor public func withDiscardingTaskGroup<GroupResult>(returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.DiscardingTaskGroup) async -> GroupResult) async -> GroupResult {
  #if compiler(>=5.5) && $BuiltinCreateTaskGroupWithFlags
  let flags = taskGroupCreateFlags(
    discardResults: true
  )

  let _group = Builtin.createTaskGroupWithFlags(flags, GroupResult.self)
  var group = DiscardingTaskGroup(group: _group)
  defer { Builtin.destroyTaskGroup(_group) }

  let result = await body(&group)

  try! await group.awaitAllRemainingTasks()  

  return result
  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen public struct DiscardingTaskGroup {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  @usableFromInline
  internal mutating func awaitAllRemainingTasks() async throws
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> Swift.Void) {
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) {
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) {
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async -> Swift.Void) -> Swift.Bool {
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
#elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
#else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
#endif

    return true
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) -> Swift.Bool {
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
#elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
#else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
#endif

    return true
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Swift.Void) -> Swift.Bool {
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

     
#if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
#elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
#else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
#endif

    return true
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(operation: __owned @escaping @isolated(any) @Sendable () async -> Swift.Void) {
    let flags = taskCreateFlags(
      priority: nil, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(operation: __owned @escaping @Sendable () async -> Swift.Void) {
    let flags = taskCreateFlags(
      priority: nil, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(operation: __owned @escaping @isolated(any) @Sendable () async -> Swift.Void) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }

    let flags = taskCreateFlags(
      priority: nil, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(operation: __owned @escaping @Sendable () async -> Swift.Void) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }

    let flags = taskCreateFlags(
      priority: nil, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@available(*, unavailable)
extension _Concurrency.DiscardingTaskGroup : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@inlinable @_unsafeInheritExecutor public func withThrowingDiscardingTaskGroup<GroupResult>(returning returnType: GroupResult.Type = GroupResult.self, body: (inout _Concurrency.ThrowingDiscardingTaskGroup<any Swift.Error>) async throws -> GroupResult) async throws -> GroupResult {
  #if compiler(>=5.5) && $BuiltinCreateTaskGroupWithFlags
  let flags = taskGroupCreateFlags(
      discardResults: true
  )

  let _group = Builtin.createTaskGroupWithFlags(flags, GroupResult.self)
  var group = ThrowingDiscardingTaskGroup<Error>(group: _group)
  defer { Builtin.destroyTaskGroup(_group) }

  let result: GroupResult
  do {
    result = try await body(&group)
  } catch {
    group.cancelAll()

    try await group.awaitAllRemainingTasks(bodyError: error)

    throw error
  }

  try await group.awaitAllRemainingTasks(bodyError: nil)

  return result
  #else
  fatalError("Swift compiler is incompatible with this SDK version")
  #endif
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen public struct ThrowingDiscardingTaskGroup<Failure> where Failure : Swift.Error {
  @usableFromInline
  internal let _group: Builtin.RawPointer
  @inlinable internal init(group: Builtin.RawPointer) {
    self._group = group
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @usableFromInline
  internal mutating func awaitAllRemainingTasks(bodyError: (any Swift.Error)?) async throws
  #else
  @usableFromInline
  internal mutating func awaitAllRemainingTasks(bodyError: (any Swift.Error)?) async throws
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> Swift.Void) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTask(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: true, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @isolated(any) @Sendable () async throws -> Swift.Void) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #elseif compiler(>=5.3) && $NoncopyableGenerics
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #else
  @_alwaysEmitIntoClient public mutating func addTaskUnlessCancelled(priority: _Concurrency.TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Swift.Void) -> Swift.Bool {
#if compiler(>=5.5) && $BuiltinCreateAsyncTaskInGroup
    let canAdd = _taskGroupAddPendingTask(group: _group, unconditionally: false)

    guard canAdd else {
       
      return false
    }

    let flags = taskCreateFlags(
      priority: priority, isChildTask: true, copyTaskLocals: false,
      inheritContext: false, enqueueJob: true,
      addPendingGroupTaskUnconditionally: false, isDiscardingTask: true
    )

     
    #if $BuiltinCreateTask
    let builtinSerialExecutor =
      Builtin.extractFunctionIsolation(operation)?.unownedExecutor.executor

    _ = Builtin.createDiscardingTask(flags: flags,
                                     initialSerialExecutor: builtinSerialExecutor,
                                     taskGroup: _group,
                                     operation: operation)
    #elseif $BuiltinCreateAsyncDiscardingTaskInGroup
    _ = Builtin.createAsyncDiscardingTaskInGroup(flags, _group, operation)
    #else
     
     
     
     
     
     
     
     
     
    _ = Builtin.createAsyncTaskInGroup(flags, _group, operation)
    #endif

    return true
#else
    fatalError("Unsupported Swift compiler")
#endif
  }
  #endif
  public var isEmpty: Swift.Bool {
    get
  }
  public func cancelAll()
  public var isCancelled: Swift.Bool {
    get
  }
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@available(*, unavailable)
extension _Concurrency.ThrowingDiscardingTaskGroup : Swift.Sendable {
}
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@usableFromInline
@discardableResult
@_silgen_name("swift_taskGroup_waitAll")
internal func _taskGroupWaitAll<T>(group: Builtin.RawPointer, bodyError: (any Swift.Error)?) async throws -> T?
#else
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@usableFromInline
@discardableResult
@_silgen_name("swift_taskGroup_waitAll")
internal func _taskGroupWaitAll<T>(group: Builtin.RawPointer, bodyError: (any Swift.Error)?) async throws -> T?
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@propertyWrapper final public class TaskLocal<Value> : Swift.Sendable, Swift.CustomStringConvertible where Value : Swift.Sendable {
  public init(wrappedValue defaultValue: Value)
  @_alwaysEmitIntoClient final internal var key: Builtin.RawPointer {
    get {
    unsafeBitCast(self, to: Builtin.RawPointer.self)
  }
  }
  final public func get() -> Value
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  @discardableResult
  @inlinable final public func withValue<R>(_ valueDuringOperation: Value, operation: () async throws -> R, isolation: isolated (any _Concurrency.Actor)? = #isolation, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
    return try await withValueImpl(
      valueDuringOperation,
      operation: operation,
      isolation: isolation,
      file: file, line: line)
  }
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  @discardableResult
  @inlinable final public func withValue<R>(_ valueDuringOperation: Value, operation: () async throws -> R, isolation: isolated (any _Concurrency.Actor)? = #isolation, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
    return try await withValueImpl(
      valueDuringOperation,
      operation: operation,
      isolation: isolation,
      file: file, line: line)
  }
  #endif
  #endif
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @usableFromInline
  @discardableResult
  @_silgen_name("$ss9TaskLocalC9withValue_9operation4file4lineqd__x_qd__yYaKXESSSutYaKlF")
  @_unsafeInheritExecutor final internal func __abi_withValue<R>(_ valueDuringOperation: Value, operation: () async throws -> R, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R
  #if compiler(>=5.3) && $OptionalIsolatedParameters
  #if $NoncopyableGenerics
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  @discardableResult
  @inlinable final internal func withValueImpl<R>(_ valueDuringOperation: __owned Value, operation: () async throws -> R, isolation: isolated (any _Concurrency.Actor)?, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
     
    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)

    _taskLocalValuePush(key: key, value: consume valueDuringOperation)
    defer { _taskLocalValuePop() }

    return try await operation()
  }
  #else
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0)
  @discardableResult
  @inlinable final internal func withValueImpl<R>(_ valueDuringOperation: __owned Value, operation: () async throws -> R, isolation: isolated (any _Concurrency.Actor)?, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
     
    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)

    _taskLocalValuePush(key: key, value: consume valueDuringOperation)
    defer { _taskLocalValuePop() }

    return try await operation()
  }
  #endif
  #endif
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  @discardableResult
  @inlinable @_unsafeInheritExecutor final internal func withValueImpl<R>(_ valueDuringOperation: __owned Value, operation: () async throws -> R, file: Swift.String = #fileID, line: Swift.UInt = #line) async rethrows -> R {
     
    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)

    _taskLocalValuePush(key: key, value: consume valueDuringOperation)
    defer { _taskLocalValuePop() }

    return try await operation()
  }
  @discardableResult
  @inlinable final public func withValue<R>(_ valueDuringOperation: Value, operation: () throws -> R, file: Swift.String = #fileID, line: Swift.UInt = #line) rethrows -> R {
     
    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)

    _taskLocalValuePush(key: key, value: valueDuringOperation)
    defer { _taskLocalValuePop() }

    return try operation()
  }
  final public var projectedValue: _Concurrency.TaskLocal<Value> {
    get
    @available(*, unavailable, message: "use '$myTaskLocal.withValue(_:do:)' instead")
    set
  }
  @available(*, unavailable, message: "property wrappers cannot be instance members")
  public static subscript(_enclosingInstance object: Swift.Never, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<Swift.Never, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<Swift.Never, _Concurrency.TaskLocal<Value>>) -> Value {
    get
  }
  final public var wrappedValue: Value {
    get
  }
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_localValuePush")
internal func _taskLocalValuePush<Value>(key: Builtin.RawPointer, value: __owned Value)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_localValuePop")
internal func _taskLocalValuePop()
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
internal func _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: Swift.String, line: Swift.UInt)
#if compiler(>=5.3) && $NoncopyableGenerics
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportIllegalTaskLocalBindingWithinWithTaskGroup")
internal func _reportIllegalTaskLocalBindingWithinWithTaskGroup(_ _filenameStart: Swift.UnsafePointer<Swift.Int8>, _ _filenameLength: Swift.Int, _ _filenameIsASCII: Swift.Bool, _ _line: Swift.UInt)
#else
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportIllegalTaskLocalBindingWithinWithTaskGroup")
internal func _reportIllegalTaskLocalBindingWithinWithTaskGroup(_ _filenameStart: Swift.UnsafePointer<Swift.Int8>, _ _filenameLength: Swift.Int, _ _filenameIsASCII: Swift.Bool, _ _line: Swift.UInt)
#endif
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  @available(*, deprecated, renamed: "Task.sleep(nanoseconds:)")
  public static func sleep(_ duration: Swift.UInt64) async
  public static func sleep(nanoseconds duration: Swift.UInt64) async throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncStream<Element> {
  public struct Continuation : Swift.Sendable {
    public enum Termination {
      case finished
      case cancelled
      public static func == (a: _Concurrency.AsyncStream<Element>.Continuation.Termination, b: _Concurrency.AsyncStream<Element>.Continuation.Termination) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum YieldResult {
      case enqueued(remaining: Swift.Int)
      case dropped(Element)
      case terminated
    }
    public enum BufferingPolicy {
      case unbounded
      case bufferingOldest(Swift.Int)
      case bufferingNewest(Swift.Int)
    }
    @discardableResult
    public func yield(_ value: __owned Element) -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult
    public func finish()
    #if compiler(>=5.3) && $NoncopyableGenerics
    public var onTermination: (@Sendable (_Concurrency.AsyncStream<Element>.Continuation.Termination) -> Swift.Void)? {
      get
      nonmutating set
    }
    #else
    public var onTermination: (@Sendable (_Concurrency.AsyncStream<Element>.Continuation.Termination) -> Swift.Void)? {
      get
      nonmutating set
    }
    #endif
  }
  public init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded, _ build: (_Concurrency.AsyncStream<Element>.Continuation) -> Swift.Void)
  #if compiler(>=5.3) && $NoncopyableGenerics
  public init(unfolding produce: @escaping () async -> Element?, onCancel: (@Sendable () -> Swift.Void)? = nil)
  #else
  public init(unfolding produce: @escaping () async -> Element?, onCancel: (@Sendable () -> Swift.Void)? = nil)
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream : _Concurrency.AsyncSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $NoncopyableGenerics
    public mutating func next() async -> Element?
    #else
    public mutating func next() async -> Element?
    #endif
    #if compiler(>=5.3) && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async -> Element?
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async -> Element?
    #endif
    #endif
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #endif
  }
  public func makeAsyncIterator() -> _Concurrency.AsyncStream<Element>.Iterator
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias AsyncIterator = _Concurrency.AsyncStream<Element>.Iterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  public func yield(with result: Swift.Result<Element, Swift.Never>) -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult
  #else
  @discardableResult
  public func yield(with result: Swift.Result<Element, Swift.Never>) -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult
  #endif
  @discardableResult
  public func yield() -> _Concurrency.AsyncStream<Element>.Continuation.YieldResult where Element == ()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  public static func makeStream(of elementType: Element.Type = Element.self, bufferingPolicy limit: _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded) -> (stream: _Concurrency.AsyncStream<Element>, continuation: _Concurrency.AsyncStream<Element>.Continuation) {
    var continuation: AsyncStream<Element>.Continuation!
    let stream = AsyncStream<Element>(bufferingPolicy: limit) { continuation = $0 }
    return (stream: stream, continuation: continuation!)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct AsyncThrowingStream<Element, Failure> where Failure : Swift.Error {
  public struct Continuation : Swift.Sendable {
    public enum Termination {
      case finished(Failure?)
      case cancelled
    }
    public enum YieldResult {
      case enqueued(remaining: Swift.Int)
      case dropped(Element)
      case terminated
    }
    public enum BufferingPolicy {
      case unbounded
      case bufferingOldest(Swift.Int)
      case bufferingNewest(Swift.Int)
    }
    @discardableResult
    public func yield(_ value: __owned Element) -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult
    #if compiler(>=5.3) && $NoncopyableGenerics
    public func finish(throwing error: __owned Failure? = nil)
    #else
    public func finish(throwing error: __owned Failure? = nil)
    #endif
    #if compiler(>=5.3) && $NoncopyableGenerics
    public var onTermination: (@Sendable (_Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.Termination) -> Swift.Void)? {
      get
      nonmutating set
    }
    #else
    public var onTermination: (@Sendable (_Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.Termination) -> Swift.Void)? {
      get
      nonmutating set
    }
    #endif
  }
  public init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.BufferingPolicy = .unbounded, _ build: (_Concurrency.AsyncThrowingStream<Element, Failure>.Continuation) -> Swift.Void) where Failure == any Swift.Error
  #if compiler(>=5.3) && $NoncopyableGenerics
  public init(unfolding produce: @escaping () async throws -> Element?) where Failure == any Swift.Error
  #else
  public init(unfolding produce: @escaping () async throws -> Element?) where Failure == any Swift.Error
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream : _Concurrency.AsyncSequence {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $NoncopyableGenerics
    public mutating func next() async throws -> Element?
    #else
    public mutating func next() async throws -> Element?
    #endif
    #if compiler(>=5.3) && $TypedThrows && $OptionalIsolatedParameters
    #if $NoncopyableGenerics
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Failure) -> Element?
    #else
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public mutating func next(isolation actor: isolated (any _Concurrency.Actor)?) async throws(Failure) -> Element?
    #endif
    #endif
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Failure
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
    public typealias __AsyncIteratorProtocol_Failure = Failure
    #endif
  }
  public func makeAsyncIterator() -> _Concurrency.AsyncThrowingStream<Element, Failure>.Iterator
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias AsyncIterator = _Concurrency.AsyncThrowingStream<Element, Failure>.Iterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Failure
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, macOS 15.0, visionOS 2.0, *)
  public typealias __AsyncSequence_Failure = Failure
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream.Continuation {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @discardableResult
  public func yield(with result: Swift.Result<Element, Failure>) -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Failure == any Swift.Error
  #else
  @discardableResult
  public func yield(with result: Swift.Result<Element, Failure>) -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Failure == any Swift.Error
  #endif
  @discardableResult
  public func yield() -> _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Element == ()
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0)
  public static func makeStream(of elementType: Element.Type = Element.self, throwing failureType: Failure.Type = Failure.self, bufferingPolicy limit: _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation.BufferingPolicy = .unbounded) -> (stream: _Concurrency.AsyncThrowingStream<Element, Failure>, continuation: _Concurrency.AsyncThrowingStream<Element, Failure>.Continuation) where Failure == any Swift.Error {
    var continuation: AsyncThrowingStream<Element, Failure>.Continuation!
    let stream = AsyncThrowingStream<Element, Failure>(bufferingPolicy: limit) { continuation = $0 }
    return (stream: stream, continuation: continuation!)
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncThrowingStream : @unchecked Swift.Sendable where Element : Swift.Sendable {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Clock<Duration> : Swift.Sendable {
  associatedtype Duration where Self.Duration == Self.Instant.Duration
  associatedtype Instant : Swift.InstantProtocol
  var now: Self.Instant { get }
  var minimumResolution: Self.Duration { get }
  #if compiler(>=5.3) && $NoncopyableGenerics
  func sleep(until deadline: Self.Instant, tolerance: Self.Instant.Duration?) async throws
  #else
  func sleep(until deadline: Self.Instant, tolerance: Self.Instant.Duration?) async throws
  #endif
}
#else
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Clock : Swift.Sendable {
  associatedtype Duration where Self.Duration == Self.Instant.Duration
  associatedtype Instant : Swift.InstantProtocol
  var now: Self.Instant { get }
  var minimumResolution: Self.Duration { get }
  #if compiler(>=5.3) && $NoncopyableGenerics
  func sleep(until deadline: Self.Instant, tolerance: Self.Instant.Duration?) async throws
  #else
  func sleep(until deadline: Self.Instant, tolerance: Self.Instant.Duration?) async throws
  #endif
}
#endif
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Clock {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func measure(_ work: () throws -> Swift.Void) rethrows -> Self.Instant.Duration
  #if compiler(>=5.3) && $ExpressionMacroDefaultArguments
  #if $NoncopyableGenerics
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public func measure(isolation: isolated (any _Concurrency.Actor)? = #isolation, _ work: () async throws -> Swift.Void) async rethrows -> Self.Instant.Duration {
    try await measure(work)
  }
  #elseif $OptionalIsolatedParameters
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public func measure(isolation: isolated (any _Concurrency.Actor)? = #isolation, _ work: () async throws -> Swift.Void) async rethrows -> Self.Instant.Duration {
    try await measure(work)
  }
  #else
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public func measure(isolation: (any _Concurrency.Actor)? = nil, _ work: () async throws -> Swift.Void) async rethrows -> Self.Instant.Duration {
    try await measure(work)
  }
  #endif
  #endif
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @usableFromInline
  @_unsafeInheritExecutor internal func measure(_ work: () async throws -> Swift.Void) async rethrows -> Self.Instant.Duration
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Clock {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public func sleep(for duration: Self.Instant.Duration, tolerance: Self.Instant.Duration? = nil) async throws {
    try await sleep(until: now.advanced(by: duration), tolerance: tolerance)
  }
  #else
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public func sleep(for duration: Self.Instant.Duration, tolerance: Self.Instant.Duration? = nil) async throws {
    try await sleep(until: now.advanced(by: duration), tolerance: tolerance)
  }
  #endif
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct ContinuousClock : Swift.Sendable {
  public struct Instant : Swift.Codable, Swift.Sendable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public init()
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Clock where Self == _Concurrency.ContinuousClock {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var continuous: _Concurrency.ContinuousClock {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.ContinuousClock : _Concurrency.Clock {
  public var now: _Concurrency.ContinuousClock.Instant {
    get
  }
  public var minimumResolution: Swift.Duration {
    get
  }
  public static var now: _Concurrency.ContinuousClock.Instant {
    get
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  public func sleep(until deadline: _Concurrency.ContinuousClock.Instant, tolerance: Swift.Duration? = nil) async throws
  #else
  public func sleep(until deadline: _Concurrency.ContinuousClock.Instant, tolerance: Swift.Duration? = nil) async throws
  #endif
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Duration = Swift.Duration
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.ContinuousClock.Instant : Swift.InstantProtocol {
  public static var now: _Concurrency.ContinuousClock.Instant {
    get
  }
  public func advanced(by duration: Swift.Duration) -> _Concurrency.ContinuousClock.Instant
  public func duration(to other: _Concurrency.ContinuousClock.Instant) -> Swift.Duration
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: _Concurrency.ContinuousClock.Instant, rhs: _Concurrency.ContinuousClock.Instant) -> Swift.Bool
  public static func < (lhs: _Concurrency.ContinuousClock.Instant, rhs: _Concurrency.ContinuousClock.Instant) -> Swift.Bool
  @_alwaysEmitIntoClient @inlinable public static func + (lhs: _Concurrency.ContinuousClock.Instant, rhs: Swift.Duration) -> _Concurrency.ContinuousClock.Instant {
    lhs.advanced(by: rhs)
  }
  @_alwaysEmitIntoClient @inlinable public static func += (lhs: inout _Concurrency.ContinuousClock.Instant, rhs: Swift.Duration) {
    lhs = lhs.advanced(by: rhs)
  }
  @_alwaysEmitIntoClient @inlinable public static func - (lhs: _Concurrency.ContinuousClock.Instant, rhs: Swift.Duration) -> _Concurrency.ContinuousClock.Instant {
    lhs.advanced(by: .zero - rhs)
  }
  @_alwaysEmitIntoClient @inlinable public static func -= (lhs: inout _Concurrency.ContinuousClock.Instant, rhs: Swift.Duration) {
    lhs = lhs.advanced(by: .zero - rhs)
  }
  @_alwaysEmitIntoClient @inlinable public static func - (lhs: _Concurrency.ContinuousClock.Instant, rhs: _Concurrency.ContinuousClock.Instant) -> Swift.Duration {
    rhs.duration(to: lhs)
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Duration = Swift.Duration
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct SuspendingClock : Swift.Sendable {
  public struct Instant : Swift.Codable, Swift.Sendable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public init()
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Clock where Self == _Concurrency.SuspendingClock {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var suspending: _Concurrency.SuspendingClock {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.SuspendingClock : _Concurrency.Clock {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var now: _Concurrency.SuspendingClock.Instant {
    get
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var now: _Concurrency.SuspendingClock.Instant {
    get
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var minimumResolution: Swift.Duration {
    get
  }
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func sleep(until deadline: _Concurrency.SuspendingClock.Instant, tolerance: Swift.Duration? = nil) async throws
  #else
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func sleep(until deadline: _Concurrency.SuspendingClock.Instant, tolerance: Swift.Duration? = nil) async throws
  #endif
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Duration = Swift.Duration
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.SuspendingClock.Instant : Swift.InstantProtocol {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static var now: _Concurrency.SuspendingClock.Instant {
    get
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func advanced(by duration: Swift.Duration) -> _Concurrency.SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func duration(to other: _Concurrency.SuspendingClock.Instant) -> Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func == (lhs: _Concurrency.SuspendingClock.Instant, rhs: _Concurrency.SuspendingClock.Instant) -> Swift.Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func < (lhs: _Concurrency.SuspendingClock.Instant, rhs: _Concurrency.SuspendingClock.Instant) -> Swift.Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func + (lhs: _Concurrency.SuspendingClock.Instant, rhs: Swift.Duration) -> _Concurrency.SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func += (lhs: inout _Concurrency.SuspendingClock.Instant, rhs: Swift.Duration)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func - (lhs: _Concurrency.SuspendingClock.Instant, rhs: Swift.Duration) -> _Concurrency.SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func -= (lhs: inout _Concurrency.SuspendingClock.Instant, rhs: Swift.Duration)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func - (lhs: _Concurrency.SuspendingClock.Instant, rhs: _Concurrency.SuspendingClock.Instant) -> Swift.Duration
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Duration = Swift.Duration
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func sleep<C>(until deadline: C.Instant, tolerance: C.Instant.Duration? = nil, clock: C = ContinuousClock()) async throws where C : _Concurrency.Clock
  #else
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public static func sleep<C>(until deadline: C.Instant, tolerance: C.Instant.Duration? = nil, clock: C = ContinuousClock()) async throws where C : _Concurrency.Clock
  #endif
  #if compiler(>=5.3) && $NoncopyableGenerics
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func sleep<C>(for duration: C.Instant.Duration, tolerance: C.Instant.Duration? = nil, clock: C = ContinuousClock()) async throws where C : _Concurrency.Clock {
    try await clock.sleep(for: duration, tolerance: tolerance)
  }
  #else
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public static func sleep<C>(for duration: C.Instant.Duration, tolerance: C.Instant.Duration? = nil, clock: C = ContinuousClock()) async throws where C : _Concurrency.Clock {
    try await clock.sleep(for: duration, tolerance: tolerance)
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation.Termination : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncStream.Continuation.Termination : Swift.Hashable {}
